import { proxyCustomElement, HTMLElement, forceUpdate, h, Host } from '@stencil/core/internal/client';
import { a as allIllustrations } from './illustrations.js';
import { d as defineCustomElement$2 } from './pn-icon2.js';

const pnTileCss = "pn-tile{position:relative;font-size:1em;}pn-tile a.pn-tile-link{position:absolute;top:0;left:0;height:100%;width:100%;pointer-events:none;opacity:0}pn-tile .pn-tile{border:0.1rem solid #d3cecb;outline:none;background:white;-webkit-box-shadow:0 0.1rem 0.2rem rgba(0, 0, 0, 0.2);box-shadow:0 0.1rem 0.2rem rgba(0, 0, 0, 0.2);cursor:pointer;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:start;align-items:flex-start;-ms-flex-pack:center;justify-content:center;padding:1.5em;padding:min(7%, 1.5em);word-break:break-word;text-decoration:none;border-radius:0.8rem;-webkit-transition:background 0.2s linear, border 0.1s linear, -webkit-box-shadow 0.1s cubic-bezier(0.6, 0, 0.2, 1) 0.1s;transition:background 0.2s linear, border 0.1s linear, -webkit-box-shadow 0.1s cubic-bezier(0.6, 0, 0.2, 1) 0.1s;transition:box-shadow 0.1s cubic-bezier(0.6, 0, 0.2, 1) 0.1s, background 0.2s linear, border 0.1s linear;transition:box-shadow 0.1s cubic-bezier(0.6, 0, 0.2, 1) 0.1s, background 0.2s linear, border 0.1s linear, -webkit-box-shadow 0.1s cubic-bezier(0.6, 0, 0.2, 1) 0.1s;position:relative;overflow:hidden;text-align:left;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;height:100%}pn-tile .pn-tile.vertical,pn-tile .pn-tile.simple{text-align:center}pn-tile .pn-tile.vertical h3,pn-tile .pn-tile.simple h3{font-size:1.5em;font-size:clamp(1em, var(--w) * 1.4, 1.5em)}pn-tile .pn-tile.vertical .tile-slot,pn-tile .pn-tile.simple .tile-slot{font-size:1em;font-size:clamp(1.2rem, var(--w), 1em)}pn-tile .pn-tile.vertical>*,pn-tile .pn-tile.simple>*{margin:0.5em 0}pn-tile .pn-tile.simple{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center}pn-tile .pn-tile.simple .tile-slot{display:none}pn-tile .pn-tile.simple h3>pn-icon{margin-left:0.1em;vertical-align:bottom}pn-tile .pn-tile.simple>*{margin:0.5em}pn-tile .pn-tile.simple>.text-cont{margin:0.5em}pn-tile .pn-tile.simple>svg,pn-tile .pn-tile.simple>.tile-illustration-slot{max-width:clamp(3em, 70%, 10em)}pn-tile .pn-tile.simple>svg,pn-tile .pn-tile.simple>.tile-illustration-slot,pn-tile .pn-tile.simple>.text-cont{-ms-flex:auto;flex:auto}pn-tile .pn-tile>*{margin:0.5em;z-index:2}pn-tile .pn-tile>svg,pn-tile .pn-tile>.tile-illustration-slot{width:100%;max-width:8em;-ms-flex:0.5 3 calc((32rem - 100%) * 999);flex:0.5 3 calc((32rem - 100%) * 999);z-index:2}pn-tile .pn-tile>.tile-illustration-slot{max-width:13em}pn-tile .pn-tile>.tile-illustration-slot>*{width:100%;display:block}pn-tile .pn-tile>.text-cont{-ms-flex:1 1 calc((32rem - 100%) * 999);flex:1 1 calc((32rem - 100%) * 999)}pn-tile .pn-tile h3{color:#005d92;font-size:1.5em}pn-tile .pn-tile .tile-slot{color:#5e554a;margin-top:0.25em}pn-tile a:focus+.pn-tile{-webkit-box-shadow:0 0 0 0.3rem white, 0 0 0 0.6rem #005d92;box-shadow:0 0 0 0.3rem white, 0 0 0 0.6rem #005d92}pn-tile a:focus+.pn-tile,pn-tile .pn-tile:hover{background:#effbff}pn-tile .pn-tile:hover,pn-tile a:focus+.pn-tile{border:0.1rem solid #8eddf9}pn-tile .pn-tile:hover.vertical .tile-circle,pn-tile .pn-tile:hover.simple .tile-circle,pn-tile a:focus+.pn-tile.vertical .tile-circle,pn-tile a:focus+.pn-tile.simple .tile-circle{-webkit-transform:translate(-50%, -90%);transform:translate(-50%, -90%);-webkit-transform:translate(-50%, calc(var(--w) * 2 - 90%));transform:translate(-50%, calc(var(--w) * 2 - 90%));opacity:1}pn-tile .pn-tile .tile-circle{position:absolute;top:0;left:50%;width:40em;height:40em;margin:0;background-color:#005d92;border-radius:50%;z-index:1;-webkit-transform:translate(-50%, -100%);transform:translate(-50%, -100%);-webkit-transition:opacity 0.4s cubic-bezier(0.7, 0, 0.3, 1), -webkit-transform 0.5s cubic-bezier(0.7, 0, 0.3, 1);transition:opacity 0.4s cubic-bezier(0.7, 0, 0.3, 1), -webkit-transform 0.5s cubic-bezier(0.7, 0, 0.3, 1);transition:transform 0.5s cubic-bezier(0.7, 0, 0.3, 1), opacity 0.4s cubic-bezier(0.7, 0, 0.3, 1);transition:transform 0.5s cubic-bezier(0.7, 0, 0.3, 1), opacity 0.4s cubic-bezier(0.7, 0, 0.3, 1), -webkit-transform 0.5s cubic-bezier(0.7, 0, 0.3, 1);opacity:0}pn-tile .pn-ripple{-webkit-animation:ripple 0.4s cubic-bezier(0.7, 0, 0.3, 1);animation:ripple 0.4s cubic-bezier(0.7, 0, 0.3, 1);position:absolute;border-radius:50%;background:#005d92;-webkit-transform:translate(-50%, -50%) scale(0);transform:translate(-50%, -50%) scale(0);opacity:0.05}@-webkit-keyframes ripple{to{-webkit-transform:translate(-50%, -50%) scale(1);transform:translate(-50%, -50%) scale(1);opacity:0}}@keyframes ripple{to{-webkit-transform:translate(-50%, -50%) scale(1);transform:translate(-50%, -50%) scale(1);opacity:0}}";

const Pntile = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    /** The rel attribute of the link */
    this.rel = 'noopener';
    /** You can pass an illustration name, but if you want to pass your own image you can add an image as a slot with the name of "illustration", check the "tile with slot" story. */
    this.illustration = null;
    /** This is to keep track of whether the tile has a description or just a title */
    this.simple = false;
    this.emInPx = 16;
    this.titleEl = null;
    //@ts-ignore
    this.checkCardSize = new ResizeObserver((cards) => {
      const getCardWidth = (width) => {
        // CardWidth is the em equivalent to 10% of the width of the card
        const cardWidth = (width * 0.1) / this.emInPx;
        return `${cardWidth}em`;
      };
      cards.forEach((card) => {
        const width = card.contentRect.width;
        card.target.classList.toggle('vertical', width < this.remToPx(31.99));
        requestAnimationFrame(() => {
          card.target.style.setProperty('--w', getCardWidth(width));
        });
      });
    });
    /*---------------------------------------UTILS-------------------------------------------*/
    this.longpress = false;
  }
  setIllustration() {
    const illustrationElement = this.hostElement.querySelector('.tile-illustration');
    if (!this.illustration) {
      illustrationElement.remove();
      return;
    }
    const illustration = allIllustrations[this.illustration];
    illustrationElement.outerHTML = illustration;
  }
  componentWillLoad() {
    const slottedIllustration = this.hostElement.querySelector('[slot="illustration"]');
    this.illustration = slottedIllustration ? null : this.illustration;
  }
  componentDidLoad() {
    if (this.mo)
      this.mo.disconnect();
    const mo = (this.mo = new MutationObserver(() => forceUpdate(this.hostElement)));
    mo.observe(this.hostElement, { childList: true });
    this.setIllustration();
    const cardEl = this.hostElement.querySelector('.pn-tile');
    const linkEl = this.hostElement.querySelector('.pn-tile-link');
    this.checkCardSize.observe(cardEl);
    this.clickHandler([linkEl, cardEl], (e) => this.ripple(e, cardEl));
    this.simple = !this.hostElement.querySelector('.tile-slot').textContent.trim();
    this.emInPx = parseFloat(window.getComputedStyle(this.hostElement).fontSize);
  }
  remToPx(rem) {
    return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
  }
  ripple(e, el) {
    if (!e.isTrusted)
      return;
    const elRect = el.getBoundingClientRect();
    const elLeft = elRect.left;
    const elTop = elRect.top;
    const rippleEl = document.createElement('div');
    const elSize = elRect.width > elRect.height ? elRect.width : elRect.height;
    rippleEl.classList.add('pn-ripple');
    el.appendChild(rippleEl);
    rippleEl.style.height = `${elSize * 2}px`;
    rippleEl.style.width = `${elSize * 2}px`;
    rippleEl.style.left = e.clientX > 0 ? `${e.clientX - elLeft}px` : `50%`;
    rippleEl.style.top = e.clientY > 0 ? `${e.clientY - elTop}px` : `50%`;
    setTimeout(() => rippleEl.remove(), 400);
  }
  clickHandler(els, callback) {
    const events = ['mouseup', 'mousedown'];
    const excludedElements = ['pn-button', 'button', 'a', 'input', 'pn-checkbox', 'pn-radio-button'];
    els.forEach((el) => {
      if (el.tagName === 'A') {
        el.addEventListener('click', (e) => {
          callback(e);
        });
      }
      else {
        events.forEach((e) => {
          el.addEventListener(e, (event) => {
            // Stop the tile-link from being pressed if the user clicks a link or a button that exists on the tile
            // This is to allow the consumer to add external actions to the tile
            const isExcludedElement = excludedElements.some((el) => event.target.closest(el));
            if (isExcludedElement)
              return;
            if (event.type === 'mousedown') {
              this.longpress = false;
              this.timer = setTimeout(() => (this.longpress = true), 200);
            }
            if (event.type === 'mouseup') {
              clearTimeout(this.timer);
              // Stop clicks in case of:
              // * Long press
              // * Right mouse button is used
              if (this.longpress || event.button === 2)
                return;
              const link = event.target.closest('pn-tile').querySelector('a');
              event.preventDefault();
              callback(event);
              // Don't refocus if already in focus
              if (!link.matches(':focus'))
                link.focus();
              // If the tile or link was clicked when the ctrl key, cmd key or middle mouse button
              // was pressed, open in a new window
              if (event.ctrlKey || event.metaKey || event.button === 1) {
                window.open(link.getAttribute('href'), '_blank');
                return;
              }
              link.click();
            }
          });
        });
      }
    });
  }
  /*---------------------------------------/UTILS-------------------------------------------*/
  getClassNames() {
    let classNames = 'pn-tile ';
    if (this.simple)
      classNames += 'simple ';
    return classNames;
  }
  render() {
    const linkAttributes = {
      href: this.url,
      target: this.target,
      rel: !this.rel && this.target === '_blank' ? 'noopener' : this.rel,
    };
    return (h(Host, null, h("a", Object.assign({ class: "pn-tile-link" }, linkAttributes), this.label), h("div", { class: this.getClassNames() }, h("div", { class: "tile-circle" }), h("div", { class: "tile-illustration" }), !this.illustration && (h("div", { class: "tile-illustration-slot" }, h("slot", { name: "illustration" }))), h("div", { class: "text-cont" }, h("h3", null, this.label, this.target === '_blank' ? h("pn-icon", { symbol: "open-in-new", small: true, color: "blue700" }) : null), h("div", { class: "tile-slot" }, h("slot", null))))));
  }
  get hostElement() { return this; }
  static get style() { return pnTileCss; }
}, [4, "pn-tile", {
    "label": [1],
    "url": [1],
    "target": [1],
    "rel": [1],
    "illustration": [1025],
    "simple": [32],
    "checkCardSize": [32],
    "longpress": [32],
    "timer": [32]
  }]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["pn-tile", "pn-icon"];
  components.forEach(tagName => { switch (tagName) {
    case "pn-tile":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Pntile);
      }
      break;
    case "pn-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}

const PnTile = Pntile;
const defineCustomElement = defineCustomElement$1;

export { PnTile, defineCustomElement };
