const humanReadableFileSize = {
  KB: 1024,
  MB: 1024 * 1024,
  GB: 1024 * 1024,
  TB: 1024 * 1024 * 1024
};
const getBytesFromHumanReadableFileSize = function (sizeString) {
  const fileSizeChecker = /(\d+\.?\d*)\s?([a-zA-Z]{2})?$/;
  if (fileSizeChecker.test(sizeString)) {
    const matches = sizeString.match(fileSizeChecker);
    const unit = (matches[2] || "").toLocaleUpperCase();
    const size = parseInt(matches[1]);
    if (unit && humanReadableFileSize[unit]) {
      const baseSize = humanReadableFileSize[unit];
      return size * baseSize;
    }
    return size;
  }
  return 0;
};
const uuidv4 = function () {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (currentValue) {
    const random = (Math.random() * 16) | 0, value = currentValue == "x" ? random : (random & 0x3) | 0x8;
    return value.toString(16);
  });
};
const isNumeric = function (str) {
  if (typeof str === "number" ||
    (typeof str === "string" && /^\d+$/.test(str))) {
    return true;
  }
  return false;
};
const createDateOrNull = function (dateStr) {
  if (isNumeric(dateStr)) {
    return null;
  }
  const date = new Date(dateStr);
  if (date.toString() === "Invalid Date") {
    return null;
  }
  else {
    return date;
  }
};
const debounce = function (func, wait, immediate) {
  let timeout;
  return function () {
    const context = this, args = arguments;
    const later = function () {
      timeout = null;
      if (!immediate)
        func.apply(context, args);
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow)
      func.apply(context, args);
  };
};
const allowedLanguages = ["en", "sv", "da", "fi", "no"];
const getMonthNamesByLanguage = function (language = "en") {
  if (allowedLanguages.indexOf(language) === -1)
    language = "en";
  const monthLanguages = {
    en: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    sv: [
      "Januari",
      "Februari",
      "Mars",
      "April",
      "Maj",
      "Juni",
      "Juli",
      "Augusti",
      "September",
      "Oktober",
      "November",
      "December"
    ],
    da: [
      "Januar",
      "Februar",
      "Marts",
      "April",
      "Maj",
      "Juni",
      "Juli",
      "August",
      "September",
      "Oktober",
      "November",
      "December"
    ],
    fi: [
      "Tammikuu",
      "Helmikuu",
      "Maaliskuu",
      "Huhtikuu",
      "Toukokuu",
      "Kesäkuu",
      "Heinäkuu",
      "Elokuu",
      "Syyskuu",
      "Lokakuu",
      "Marraskuu",
      "Joulukuu"
    ],
    no: [
      "Januar",
      "Februar",
      "Mars",
      "April",
      "Mai",
      "Juni",
      "Juli",
      "August",
      "September",
      "Oktober",
      "November",
      "Desember"
    ]
  };
  return monthLanguages[language];
};
const getDayNamesByLanguage = function (language = "en") {
  if (allowedLanguages.indexOf(language) === -1)
    language = "en";
  const daysLanguages = {
    en: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    sv: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
    da: ["Søn.", "Man.", "Tirs.", "Ons. ", "Tors. ", "Fre.", "Lør."],
    fi: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
    no: ["Sø.", "Ma.", "Ti.", "On.", "To.", "Fr.", "Lø."]
  };
  return daysLanguages[language];
};
const computeMonths = function (date) {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  return (year * 12) + month;
};

export { computeMonths as a, getDayNamesByLanguage as b, createDateOrNull as c, debounce as d, getBytesFromHumanReadableFileSize as e, getMonthNamesByLanguage as g, uuidv4 as u };
