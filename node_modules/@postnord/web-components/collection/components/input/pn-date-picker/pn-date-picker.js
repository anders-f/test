import { Component, Prop, State, h, Host, Event, Listen, Element, Watch } from '@stencil/core';
import { translations } from './translations';
export class PnDatePicker {
  constructor() {
    /** Manually set language; this will be inherited from the top-bar */
    this.language = 'en';
    /** Initialize with a pre-selected start date, optional */
    this.start = null;
    /** Initialize with a pre-selected end date, optional */
    this.end = null;
    /** earliest date possible, this will determine how many years back the date picker will show  */
    this.minDate = null;
    /** latest date possible, this will determine how many years forward the date picker will show */
    this.maxDate = null;
    /** Ranged date picker, two dates */
    this.range = false;
    this.disableWeekends = false;
    /** Individual dates you want to disable, separated by comma, for example: "YYYY-MM-DD, YYYY-MM-DD..." */
    this.disabledDates = null;
    /** Placeholder for the input field (this will be start date if you have a ranged date picker) */
    this.placeholder = '';
    /** Placeholder for end date */
    this.endPlaceholder = '';
    this.currentState = 'idle';
    this.week = [];
    this.months = [];
    this.startDate = null;
    this.endDate = null;
    this.open = false;
    this.activeSelectionState = false;
    this.selectionMade = false;
    this.years = [];
    this.today = new Date();
    this.shouldScroll = true;
    /* -----------------STATE MACHINE LOGIC------------------ */
    this.machine = {
      initial: 'idle',
      states: {
        idle: {
          on: {
            click: payload => {
              this.selectionMade = false;
              const { year, month, day } = payload;
              this.startDate = new Date(year, month, day);
              if (this.range) {
                this.endDate = new Date(year, month, day);
                this.activeSelectionState = true;
                return 'dragging';
              }
              this.makeSelection();
              return 'idle';
            },
          },
        },
        dragging: {
          on: {
            pointerover: payload => {
              const { year, month, day } = payload;
              const endDate = new Date(year, month, day);
              this.endDate = endDate !== this.startDate && !this.shouldDisable(year, month, day) ? endDate : null;
              return 'dragging';
            },
            click: () => {
              this.makeSelection();
              return 'idle';
            },
            pointercancel: 'idle',
          },
        },
      },
    };
    this.handleGlobalClick = this.clickHandler.bind(this);
  }
  dateSelectionHandler() {
    this.open = false;
  }
  send(payload, event) {
    const transition = this.machine.states[this.currentState].on[event.type];
    if (typeof transition === 'function') {
      this.currentState = transition(payload, event);
    }
    else if (transition) {
      this.currentState = transition;
    }
  }
  /* -----------------/STATE MACHINE LOGIC------------------ */
  /* -----------------LIFE CYCLE HOOKS------------------ */
  componentWillLoad() {
    this.setDateFromOutside();
    this.setLanguage();
    this.setYears();
  }
  /* -----------------/LIFE CYCLE HOOKS------------------ */
  /* -----------------UTILS------------------ */
  makeSelection() {
    if (!this.range && this.startDate) {
      this.dateselection.emit(this.formatDate(this.startDate));
      return;
    }
    if (!this.startDate || !this.endDate)
      return;
    const start = this.startDate > this.endDate ? this.endDate : this.startDate;
    const end = this.endDate > this.startDate ? this.endDate : this.startDate;
    this.activeSelectionState = false;
    this.selectionMade = true;
    this.dateselection.emit({ start: this.formatDate(start), end: this.formatDate(end) });
  }
  startHandler() {
    this.setDateFromOutside();
  }
  endHandler() {
    this.setDateFromOutside();
  }
  openHandler() {
    if (this.shouldScroll)
      this.scrollToMonth();
    if (this.open) {
      document.addEventListener('click', this.handleGlobalClick);
      return;
    }
    if (!this.selectionMade && this.range)
      this.endDate = null;
    document.removeEventListener('click', this.handleGlobalClick);
  }
  scrollToMonth() {
    this.shouldScroll = false;
    const date = this.startDate && this.startDate.getTime() ? this.startDate : new Date();
    const year = date.getFullYear();
    const month = this.months[date.getMonth()];
    const monthEl = this.hostElement.querySelector(`[data-year="${year}"] [data-month="${month}"]`);
    const calendarEl = this.hostElement.querySelector('.calendar');
    calendarEl.scrollTop = monthEl.offsetTop;
  }
  clickHandler(e) {
    var _a;
    const target = (_a = e.composedPath) === null || _a === void 0 ? void 0 : _a.call(e)[0];
    if (!this.hostElement.contains(target)) {
      this.open = false;
    }
  }
  setLanguage() {
    const topbar = window.pnTopbar;
    if (topbar) {
      this.language = topbar.language;
      topbar.onChangeLanguage = language => {
        this.language = language;
        this.months = translations.MONTHS[this.language];
        this.week = translations.WEEK[this.language];
      };
    }
    this.months = translations.MONTHS[this.language];
    this.week = translations.WEEK[this.language];
  }
  setDateFromOutside() {
    if (this.start && this.checkEnabledDate(this.start))
      this.startDate = new Date(this.start);
    if (this.end && this.checkEnabledDate(this.end))
      this.endDate = new Date(this.end);
    if (this.startDate)
      this.makeSelection();
  }
  checkEnabledDate(dateString) {
    if (!this.checkValidDate(dateString))
      return;
    const date = new Date(dateString);
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    return !this.shouldDisable(year, month, day);
  }
  leadingZero(number) {
    return number < 10 ? `0${number}` : number;
  }
  formatDate(date) {
    if (!date)
      return '';
    const year = date.getFullYear();
    const month = this.leadingZero(date.getMonth() + 1);
    const day = this.leadingZero(date.getDate());
    return `${year}-${month}-${day}`;
  }
  checkValidDate(value) {
    const regEx = /^\d{4}-\d{2}-\d{2}$/;
    if (!value.match(regEx))
      return false;
    if (!new Date(value).getTime())
      return false;
    return true;
  }
  /* -----------------/UTILS------------------ */
  checkToday(year, month, day) {
    const today = this.formatDate(this.today);
    const date = this.formatDate(new Date(year, month, day));
    return today === date;
  }
  calculateSelected(year, month, day) {
    const checkDate = this.formatDate(new Date(year, month, day));
    const start = this.startDate > this.endDate ? this.formatDate(this.endDate) : this.formatDate(this.startDate);
    const end = this.endDate > this.startDate ? this.formatDate(this.endDate) : this.formatDate(this.startDate);
    // Check if there's only an end date
    if (!start && end && checkDate === end)
      return 'single';
    if (!this.startDate)
      return;
    // Check if there is only a start date
    if (start && !end && checkDate === start) {
      return 'single';
    }
    // Check if start and end are the same
    if (start && end && checkDate === start && checkDate === end) {
      return 'single';
    }
    if (checkDate > start && checkDate < end && this.endDate)
      return 'between';
    if (checkDate === start)
      return 'start';
    if (checkDate === end)
      return 'end';
    return null;
  }
  shouldDisable(year, month, day) {
    const date = new Date(year, month, day);
    if (this.minDate && this.maxDate) {
      const current = date.setHours(0, 0, 0, 0);
      const min = new Date(this.minDate).setHours(0, 0, 0, 0);
      const max = new Date(this.maxDate).setHours(0, 0, 0, 0);
      if (current < min || current > max)
        return true;
    }
    const isWeekend = this.isWeekend(date);
    if (this.disableWeekends && isWeekend)
      return true;
    if (this.disabledDates) {
      const disabledDates = this.disabledDates.split(',').map(date => date.trim());
      return disabledDates.includes(this.formatDate(date));
    }
    return false;
  }
  // For the disable weekends prop
  isWeekend(date) {
    const day = date.getDay();
    return day === 0 || day === 6;
  }
  /* -----------------/DISABLE CALCS------------------ */
  daysInMonth(month, year) {
    // Get the amount of days of a specific month and create an array of that length
    // so that we can loop over the days in the render function.
    return Array.from({ length: new Date(year, month + 1, 0).getDate() }, (_, i) => i + 1);
  }
  calcWeekdayStart(year, month, day) {
    // Sundays are indexed as 0 and our sunday column is 7.
    const getDay = new Date(year, month, day).getDay();
    const startDay = getDay === 0 ? 7 : getDay;
    return { 'grid-column-start': `${startDay}` };
  }
  setYears() {
    if (!this.minDate || !this.checkValidDate(this.minDate))
      this.minDate = `${this.today.getFullYear() - 1}-01-01`;
    if (!this.maxDate || !this.checkValidDate(this.maxDate))
      this.maxDate = `${this.today.getFullYear() + 1}-12-31`;
    const minYear = new Date(this.minDate).getFullYear();
    const maxYear = new Date(this.maxDate).getFullYear();
    for (let year = minYear; year <= maxYear; year++) {
      this.years.push(year);
    }
  }
  startInputHandler(e) {
    this.open = true;
    if (!this.checkValidDate(e.target.value))
      return null;
    const date = new Date(e.target.value);
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    if (this.shouldDisable(year, month, day)) {
      this.startDate = null;
      return;
    }
    this.startDate = new Date(e.target.value);
    this.makeSelection();
  }
  endInputHandler(e) {
    this.open = true;
    if (!this.checkValidDate(e.target.value))
      return null;
    const date = new Date(e.target.value);
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    if (this.shouldDisable(year, month, day)) {
      this.endDate = null;
      return;
    }
    this.endDate = new Date(e.target.value);
    this.makeSelection();
  }
  arrowDirection() {
    return this.endDate && this.startDate && this.endDate < this.startDate ? 'backwards' : '';
  }
  getCalendarClasses() {
    let classNames = 'calendar-wrapper ';
    if (this.activeSelectionState)
      classNames += 'active-selection ';
    return classNames;
  }
  render() {
    return (h(Host, null,
      h("div", { class: "pn-date-input-container" },
        h("input", { type: "text", value: this.startDate ? this.formatDate(this.startDate) : null, onInput: e => this.startInputHandler(e), onFocusin: () => (this.open = true), placeholder: this.placeholder }),
        this.range && h("pn-icon", { class: this.arrowDirection(), symbol: "arrow-right", color: "blue700" }),
        this.range && (h("input", { type: "text", value: this.formatDate(this.endDate), onInput: e => this.endInputHandler(e), onFocusin: () => (this.open = true), placeholder: this.endPlaceholder })),
        h("button", { class: "pn-date-calendar", type: "button", onClick: () => (this.open = !this.open) },
          h("pn-icon", { symbol: "calendar", color: "blue700" }))),
      h("div", { class: this.getCalendarClasses(), "data-open": this.open },
        h("div", { class: "calendar" }, this.years.map(year => (h("div", { "data-year": year }, this.months.map((monthString, month) => (h("div", { "data-month": monthString },
          h("h3", { class: "pn-date-picker-month" },
            monthString,
            " - ",
            year),
          h("div", { class: "month" },
            this.week.map(day => (h("h4", { class: "weekday pn-2xs" }, day))),
            this.daysInMonth(month, year).map(day => (h("button", { class: "day", style: this.calcWeekdayStart(year, month, day), "data-day": day, "data-today": this.checkToday(year, month, day), "data-selected": this.calculateSelected(year, month, day), onClick: event => this.send({ year, month, day }, event), onPointerOver: event => this.send({ year, month, day }, event), tabindex: "-1", disabled: this.shouldDisable(year, month, day), type: "button" },
              h("span", { class: "number" }, day)))))))))))))));
  }
  static get is() { return "pn-date-picker"; }
  static get originalStyleUrls() { return {
    "$": ["pn-date-picker.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["pn-date-picker.css"]
  }; }
  static get properties() { return {
    "language": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Manually set language; this will be inherited from the top-bar"
      },
      "attribute": "language",
      "reflect": false,
      "defaultValue": "'en'"
    },
    "start": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Initialize with a pre-selected start date, optional"
      },
      "attribute": "start",
      "reflect": false,
      "defaultValue": "null"
    },
    "end": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Initialize with a pre-selected end date, optional"
      },
      "attribute": "end",
      "reflect": false,
      "defaultValue": "null"
    },
    "minDate": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "earliest date possible, this will determine how many years back the date picker will show"
      },
      "attribute": "min-date",
      "reflect": false,
      "defaultValue": "null"
    },
    "maxDate": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "latest date possible, this will determine how many years forward the date picker will show"
      },
      "attribute": "max-date",
      "reflect": false,
      "defaultValue": "null"
    },
    "range": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Ranged date picker, two dates"
      },
      "attribute": "range",
      "reflect": false,
      "defaultValue": "false"
    },
    "disableWeekends": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "disable-weekends",
      "reflect": false,
      "defaultValue": "false"
    },
    "disabledDates": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Individual dates you want to disable, separated by comma, for example: \"YYYY-MM-DD, YYYY-MM-DD...\""
      },
      "attribute": "disabled-dates",
      "reflect": false,
      "defaultValue": "null"
    },
    "placeholder": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Placeholder for the input field (this will be start date if you have a ranged date picker)"
      },
      "attribute": "placeholder",
      "reflect": false,
      "defaultValue": "''"
    },
    "endPlaceholder": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Placeholder for end date"
      },
      "attribute": "end-placeholder",
      "reflect": false,
      "defaultValue": "''"
    }
  }; }
  static get states() { return {
    "currentState": {},
    "week": {},
    "months": {},
    "startDate": {},
    "endDate": {},
    "open": {},
    "activeSelectionState": {},
    "selectionMade": {},
    "machine": {}
  }; }
  static get events() { return [{
      "method": "dateselection",
      "name": "dateselection",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emits on valid date selection"
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }]; }
  static get elementRef() { return "hostElement"; }
  static get watchers() { return [{
      "propName": "start",
      "methodName": "startHandler"
    }, {
      "propName": "end",
      "methodName": "endHandler"
    }, {
      "propName": "open",
      "methodName": "openHandler"
    }]; }
  static get listeners() { return [{
      "name": "dateselection",
      "method": "dateSelectionHandler",
      "target": undefined,
      "capture": false,
      "passive": false
    }]; }
}
