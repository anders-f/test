import { Component, Prop, State, Watch, Element, h, Host } from '@stencil/core';
export class PnnavDropdown {
  constructor() {
    /** The label on the button */
    this.label = 'Dropdown';
    /** Optional icon in the button */
    this.icon = '';
    this.open = false;
    this.position = '';
    this.right = false;
    this.handleGlobalEvents = this.globalHandler.bind(this);
  }
  componentDidLoad() {
    const links = Array.from(this.hostElement.querySelectorAll('.nav-dropdown-content a'));
    const btns = Array.from(this.hostElement.querySelectorAll('.nav-dropdown-content button'));
    const inputs = Array.from(this.hostElement.querySelectorAll('.nav-dropdown-content input'));
    this.dropdown = this.hostElement.querySelector('.nav-dropdown-content-container');
    this.focusableElements = [...btns, ...links, ...inputs];
    this.toggleTabOrder();
  }
  openHandler() {
    this.toggleTabOrder();
    this.toggleDropdown();
    if (this.open) {
      document.addEventListener('click', this.handleGlobalEvents);
      document.addEventListener('keyup', this.handleGlobalEvents);
    }
    if (!this.open) {
      document.removeEventListener('click', this.handleGlobalEvents);
      document.removeEventListener('keyup', this.handleGlobalEvents);
    }
  }
  globalHandler(e) {
    // global events that we want to track to close the select, like "click outside" or tab out
    if ((!this.hostElement.contains(e.target) && e.type !== 'scroll') || (e === null || e === void 0 ? void 0 : e.key) === 'Escape') {
      this.open = false;
    }
    else if (e.type === 'scroll') {
      const top = this.hostElement.getBoundingClientRect().top;
      const bottom = window.innerHeight - this.hostElement.getBoundingClientRect().bottom;
      if (bottom <= 0 || top <= 0) {
        this.open = false;
      }
    }
  }
  toggleDropdown() {
    this.right = this.hostElement.offsetLeft > window.innerWidth / 2;
    requestAnimationFrame(() => {
      if (this.open) {
        this.dropdown.style.transition = 'none';
        this.dropdown.style.transform = 'none';
      }
      const dropdownEl = this.dropdown.getBoundingClientRect();
      let x;
      if (dropdownEl.right > window.innerWidth || dropdownEl.x < 0) {
        // 0.025 because the max width of the element is 95vw and we want the same margin on both sides
        x = dropdownEl.x + dropdownEl.width + window.innerWidth * 0.025 - window.innerWidth;
      }
      else {
        x = 0;
      }
      this.dropdown.style.transform = '';
      requestAnimationFrame(() => {
        this.dropdown.style.transition = '';
        this.dropdown.style.transform = this.open ? `scale(1) translateX(-${x}px)` : '';
        requestAnimationFrame(() => {
          this.hostElement.dataset.open = `${this.open}`;
        });
      });
    });
  }
  toggleTabOrder() {
    if (!this.focusableElements.length)
      return;
    const tabindex = this.open ? '0' : '-1';
    this.focusableElements.forEach((el) => {
      el.setAttribute('tabindex', tabindex);
    });
  }
  ripple(e) {
    const el = this.hostElement.querySelector('.pn-nav-dropdown-label');
    this.open = !this.open;
    const elRect = el.getBoundingClientRect();
    const elLeft = elRect.left;
    const elTop = elRect.top;
    const rippleEl = document.createElement('div');
    const elSize = elRect.width > elRect.height ? elRect.width : elRect.height;
    rippleEl.classList.add('pn-ripple');
    el.appendChild(rippleEl);
    rippleEl.style.height = `${elSize * 2}px`;
    rippleEl.style.width = `${elSize * 2}px`;
    rippleEl.style.left = e.clientX > 0 ? `${e.clientX - elLeft}px` : `50%`;
    rippleEl.style.top = e.clientY > 0 ? `${e.clientY - elTop}px` : `50%`;
    setTimeout(() => rippleEl.remove(), 400);
  }
  getClassNames() {
    let classNames = '';
    if (this.right)
      classNames += 'nav-dropdown-right ';
    return classNames;
  }
  render() {
    return (h(Host, { class: this.getClassNames() },
      h("button", { class: "pn-nav-dropdown-label", type: "button", onClick: (e) => this.ripple(e) },
        this.label,
        this.icon ? h("pn-icon", { symbol: this.icon, color: "blue700" }) : null),
      h("div", { class: "nav-dropdown-content-container" },
        h("div", { class: "nav-dropdown-content" },
          h("slot", null)))));
  }
  static get is() { return "pn-nav-dropdown"; }
  static get originalStyleUrls() { return {
    "$": ["pn-nav-dropdown.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["pn-nav-dropdown.css"]
  }; }
  static get properties() { return {
    "label": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "The label on the button"
      },
      "attribute": "label",
      "reflect": false,
      "defaultValue": "'Dropdown'"
    },
    "icon": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Optional icon in the button"
      },
      "attribute": "icon",
      "reflect": false,
      "defaultValue": "''"
    }
  }; }
  static get states() { return {
    "open": {},
    "position": {},
    "right": {}
  }; }
  static get elementRef() { return "hostElement"; }
  static get watchers() { return [{
      "propName": "open",
      "methodName": "openHandler"
    }]; }
}
