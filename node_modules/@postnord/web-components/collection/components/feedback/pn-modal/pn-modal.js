import { Component, Element, h, Host, Prop, State, Watch, Event, forceUpdate } from '@stencil/core';
export class PnModal {
  constructor() {
    /** Bind to this property if you want to control the visibility of the modal from your own data. */
    this.open = false;
    this.handleFocus = this.focusHandler.bind(this);
    this.handleBlur = this.blurHandler.bind(this);
    this.handleEsc = this.escHandler.bind(this);
    this.handleGlobalClick = this.globalClickHandler.bind(this);
  }
  componentDidLoad() {
    if (this.mo)
      this.mo.disconnect();
    const mo = (this.mo = new MutationObserver(() => {
      forceUpdate(this.hostElement);
      this.setFocusableElements();
    }));
    mo.observe(this.hostElement.querySelector('.pn-modal'), { childList: true, subtree: true });
    // If the modal is opened when the page loads we still want to register the events.
    if (this.open)
      this.addEventListeners();
    this.setFocusableElements();
  }
  openHandler() {
    if (this.open) {
      this.addEventListeners();
    }
    else {
      this.removeEventListeners();
      this.elToFocus = null;
      this.close.emit(this.open);
    }
  }
  setFocusableElements() {
    // This place is where I see the most coming changes/bugs taking place.
    requestAnimationFrame(() => {
      this.focusableEls = Array.from(this.hostElement.querySelectorAll('a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"]):not(.pn-modal-backdrop), pn-option'));
      this.untabbable = Array.from(this.hostElement.querySelectorAll('[tabindex="-1"]'));
    });
  }
  addEventListeners() {
    const root = this.hostElement.getRootNode();
    root.addEventListener('focusin', this.handleFocus);
    root.addEventListener('focusout', this.handleBlur);
    root.addEventListener('keydown', this.handleEsc);
    // Adding RAF to ensure clicks aren't registered before the modal has opened.
    requestAnimationFrame(() => {
      document.addEventListener('pointerdown', this.handleGlobalClick);
    });
  }
  removeEventListeners() {
    const root = this.hostElement.getRootNode();
    root.removeEventListener('focusin', this.handleFocus);
    root.removeEventListener('focusout', this.handleBlur);
    root.removeEventListener('keydown', this.handleEsc);
    document.removeEventListener('pointerdown', this.handleGlobalClick);
  }
  focusHandler(e) {
    const target = e.composedPath()[0];
    if ((!this.focusableEls.includes(target) && !this.untabbable.includes(target)) ||
      target.classList.contains('pn-modal-backdrop')) {
      if (this.elToFocus) {
        this.elToFocus.focus();
        return;
      }
      this.focusableEls[0].focus();
    }
  }
  blurHandler(e) {
    var _a;
    const target = (_a = e.composedPath) === null || _a === void 0 ? void 0 : _a.call(e)[0];
    const index = this.focusableEls.indexOf(target);
    const numberOfEls = this.focusableEls.length - 1;
    if (index === 0)
      this.elToFocus = this.focusableEls[numberOfEls];
    if (index === numberOfEls)
      this.elToFocus = this.focusableEls[0];
  }
  escHandler({ code }) {
    if (code === 'Escape')
      this.open = false;
  }
  globalClickHandler(e) {
    var _a;
    const target = (_a = e.composedPath) === null || _a === void 0 ? void 0 : _a.call(e)[0];
    if (!this.hostElement.contains(target) || target.classList.contains('pn-modal-backdrop')) {
      // This is to prevent the focus and blur events from being triggered when closing the modal.
      e.preventDefault();
      this.open = false;
    }
  }
  render() {
    return (h(Host, { "data-open": this.open },
      h("div", { class: "pn-modal-backdrop", tabindex: "0" }),
      h("div", { class: "pn-modal" },
        h("button", { class: "pn-modal-close-button", onClick: () => (this.open = false), type: "button", title: "close", "aria-label": "close" },
          h("pn-icon", { symbol: "close", color: "blue700" })),
        h("div", { class: "pn-modal-content" },
          h("slot", null)),
        h("slot", { name: "buttons" })),
      h("div", { class: "pn-modal-backdrop", tabindex: "0" })));
  }
  static get is() { return "pn-modal"; }
  static get originalStyleUrls() { return {
    "$": ["pn-modal.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["pn-modal.css"]
  }; }
  static get properties() { return {
    "open": {
      "type": "boolean",
      "mutable": true,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Bind to this property if you want to control the visibility of the modal from your own data."
      },
      "attribute": "open",
      "reflect": false,
      "defaultValue": "false"
    }
  }; }
  static get states() { return {
    "focusableEls": {}
  }; }
  static get events() { return [{
      "method": "close",
      "name": "close",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Event fired when the modal is closed, either by clicking outside or by triggering close button."
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }]; }
  static get elementRef() { return "hostElement"; }
  static get watchers() { return [{
      "propName": "open",
      "methodName": "openHandler"
    }]; }
}
