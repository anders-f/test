import { Component, h, State, Host, Event, Prop } from '@stencil/core';
import { translations } from './translations';
export class PnZipCodeSearch {
  constructor() {
    /** marketwebLanguage property will be prioritized before the state language */
    this.marketwebLanguage = '';
    /** If property marketwebLanguage is empty it will fall back on the state language */
    this.language = 'sv';
    this.loading = false;
    this.error = false;
    this.errorMessage = '';
    this.showResult = false;
    this.zipCodeSearchResult = {
      delivery: '',
      upcoming: '',
      city: '',
      postalCode: '',
    };
  }
  componentWillLoad() {
    const topbar = window.pnTopbar;
    if (topbar) {
      this.init();
    }
    else {
      window.addEventListener('topbarLoaded', () => {
        this.init();
      });
    }
  }
  init() {
    const topbar = window.pnTopbar;
    if (topbar) {
      this.language = topbar.language;
      topbar.onChangeLanguage = (language) => {
        this.language = language;
      };
    }
  }
  isEmpty(input) {
    const isNullOrUndefined = !input;
    if (isNullOrUndefined) {
      return true;
    }
    const isEmptyStr = input.trim().length === 0;
    if (isEmptyStr) {
      return true;
    }
    else {
      return false;
    }
  }
  getTranslation(keyToMatch, languageToMatch) {
    // Loop through translations
    for (const [key, languages] of Object.entries(translations)) {
      if (key === keyToMatch.toUpperCase()) {
        const englishTranslation = translations[key].en;
        // Loop through languages
        for (const [language, translation] of Object.entries(languages)) {
          if (language === languageToMatch.toLowerCase()) {
            if (this.isEmpty(translation)) {
              return englishTranslation;
            }
            else {
              return translation;
            }
          }
        }
        // If no matching language, return the english translation as fallback
        return englishTranslation;
      }
    }
    return keyToMatch; // If no translation found, return the key as last fallback
  }
  handleSearch(e) {
    const validationResult = this.validateZipCode(e.detail);
    if (validationResult.error) {
      this.error = true;
      this.errorMessage = 'VALIDATION_ERROR_MESSAGE';
      return;
    }
    // call endpoint
    this.zipCodeSearch(validationResult.value);
  }
  async zipCodeSearch(zipCode) {
    this.loading = true;
    await fetch(`https://portal.postnord.com/api/sendoutarrival/closest?postalCode=${zipCode}`)
      .then((response) => {
      return response.json();
    })
      .then((data) => {
      this.error = false;
      this.loading = false;
      this.showResult = true;
      this.zipCodeSearchResult = data;
      this.searchsuccessful.emit(true);
    })
      .catch(() => {
      this.error = true;
      this.errorMessage = 'SERVER_ERROR_MESSAGE';
      this.loading = false;
      this.searchsuccessful.emit(false);
    });
  }
  validateZipCode(value) {
    // Removes spaces and dashes
    const formatValue = value ? value.replace(/[ -]/gi, '') : '';
    // Looks for non-digits
    const postalCodeRegex = new RegExp(/\D+/);
    const error = postalCodeRegex.test(formatValue) || formatValue.length !== 5;
    return { error, value: formatValue };
  }
  renderSearchResult() {
    if (!this.loading && !this.error && this.showResult) {
      return (h("div", { class: "search-results" },
        h("div", { class: "text-row" },
          h("h3", null,
            this.getTranslation('CLOSEST_DELIVERY_DATE', this.marketwebLanguage || this.language),
            " "),
          h("h2", { class: "delivery-date" }, this.zipCodeSearchResult.delivery)),
        h("div", { class: "text-row" },
          h("h3", null,
            this.getTranslation('NEXT_DELIVERY_DATE', this.marketwebLanguage || this.language),
            " "),
          h("h2", { class: "delivery-date" }, this.zipCodeSearchResult.upcoming)),
        h("div", { class: "text-row" },
          h("h3", null, this.getTranslation('ZIP_CODE', this.marketwebLanguage || this.language)),
          h("h2", null,
            " ",
            this.zipCodeSearchResult.postalCode)),
        h("h3", null, this.zipCodeSearchResult.city)));
    }
  }
  renderErrorMessage() {
    if (this.error && !this.loading) {
      return (h("p", { class: "error-text pn-tiny" }, this.getTranslation(this.errorMessage, this.marketwebLanguage || this.language)));
    }
  }
  render() {
    return (h(Host, null,
      h("pn-search-field", { loading: this.loading, button: "none", placeholder: this.getTranslation('PLACEHOLDER_TEXT', this.marketwebLanguage || this.language), onSearch: (e) => this.handleSearch(e) }),
      this.renderSearchResult(),
      this.renderErrorMessage()));
  }
  static get is() { return "pn-zipcode-search"; }
  static get originalStyleUrls() { return {
    "$": ["pn-zipcode-search.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["pn-zipcode-search.css"]
  }; }
  static get properties() { return {
    "marketwebLanguage": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "marketwebLanguage property will be prioritized before the state language"
      },
      "attribute": "marketweb-language",
      "reflect": false,
      "defaultValue": "''"
    }
  }; }
  static get states() { return {
    "language": {},
    "loading": {},
    "error": {},
    "errorMessage": {},
    "showResult": {},
    "zipCodeSearchResult": {}
  }; }
  static get events() { return [{
      "method": "searchsuccessful",
      "name": "searchsuccessful",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Event fired when search has result"
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }]; }
}
