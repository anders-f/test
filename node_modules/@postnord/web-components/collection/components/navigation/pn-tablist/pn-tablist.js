import { Component, Prop, Listen, Element, Event, State, h, Host, Watch, forceUpdate, } from '@stencil/core';
export class PnTablist {
  constructor() {
    /** The value of the tab that is currently active */
    this.value = null;
    /** Icons are stacked vertically instead of the default rows */
    this.stackedicons = false;
    this.showScrollArrows = false;
    this.isTabHovered = false;
    this.enterHandler = this.handleEnter.bind(this);
    this.leaveHandler = this.handleLeave.bind(this);
    // We need this to be stateful because we need it to update on scroll
    this.scrollArrowClasses = 'scroll-arrows ';
  }
  valueWatcher() {
    this.setValue();
  }
  setActiveTabHandler({ detail }) {
    this.tabElement = detail.el;
    requestAnimationFrame(() => this.activateTab());
    if (this.value === detail.val)
      return;
    this.value = detail.val;
    this.tabchange.emit(this.value);
  }
  handleResize() {
    this.rerender();
  }
  componentDidLoad() {
    this.rerender();
    this.setValue();
    this.registerEvents();
    if (this.mo)
      this.mo.disconnect();
    const mo = (this.mo = new MutationObserver(() => {
      forceUpdate(this.hostElement);
      this.rerender();
      this.registerEvents();
    }));
    mo.observe(this.hostElement, { childList: true });
  }
  setValue() {
    const children = Array.from(this.hostElement.querySelectorAll('pn-tab'));
    children.forEach((child) => {
      child.activeTab = this.value;
    });
  }
  rerender() {
    requestAnimationFrame(() => {
      this.scrollIndicators();
      this.calcActiveItemHighlight();
    });
  }
  activateTab() {
    const tabListCoords = this.hostElement.getBoundingClientRect();
    const activeTabCoords = this.tabElement.querySelector('button').getBoundingClientRect();
    const scrollOffset = this.hostElement.querySelector('.tablist').scrollLeft;
    const activeLine = this.hostElement.querySelector('.line .active-line');
    const coords = {
      scale: activeTabCoords.width / tabListCoords.width,
      offset: activeTabCoords.left + scrollOffset - tabListCoords.left,
    };
    activeLine.style.setProperty('transform', `translateX(${coords.offset}px) scaleX(${coords.scale})`);
    activeLine.style.setProperty('opacity', '1');
  }
  calcActiveItemHighlight() {
    this.isTabHovered = false;
    this.tabListEl = this.hostElement.querySelector('.tablist');
    this.hoveredLine = this.tabListEl.querySelector('.hovered-line');
  }
  handleEnter(e) {
    this.isTabHovered = true;
    const hoveredTabCoords = e.target.getBoundingClientRect();
    const tabListCoords = this.tabListEl.getBoundingClientRect();
    const scrollOffset = this.tabListEl.scrollLeft;
    const coords = {
      scale: hoveredTabCoords.width / tabListCoords.width,
      offset: hoveredTabCoords.left + scrollOffset - tabListCoords.left,
    };
    this.hoveredLine.style.setProperty('transform', `translateX(${coords.offset}px) scaleX(${coords.scale})`);
    this.hoveredLine.style.setProperty('opacity', '1');
  }
  handleLeave() {
    this.isTabHovered = false;
    setTimeout(() => {
      if (!this.isTabHovered)
        this.hoveredLine.style.setProperty('opacity', '0');
    }, 500);
  }
  registerEvents() {
    const preExistingTabs = this.availableTabs ? this.availableTabs : null;
    this.availableTabs = this.hostElement.querySelectorAll('button.pn-tab');
    if (preExistingTabs) {
      this.availableTabs.forEach((tab) => {
        tab.removeEventListener('mouseenter', this.enterHandler);
        tab.removeEventListener('focus', this.enterHandler);
        tab.removeEventListener('mouseleave', this.leaveHandler);
        tab.removeEventListener('blur', this.leaveHandler);
      });
    }
    this.availableTabs.forEach((tab) => {
      tab.addEventListener('mouseenter', this.enterHandler);
      tab.addEventListener('focus', this.enterHandler);
      tab.addEventListener('mouseleave', this.leaveHandler);
      tab.addEventListener('blur', this.leaveHandler);
    });
  }
  /*---------------------------------------/HOVER LOGIC-------------------------------------------*/
  /*-------------------------------------- SCROLL RELATED ---------------------------------------------**/
  scrollHandler() {
    if (this.showScrollArrows) {
      this.hostElement.querySelector('.tablist').addEventListener('scroll', () => this.scrollIndicators());
    }
    else {
      this.hostElement.querySelector('.tablist').removeEventListener('scroll', () => this.scrollIndicators());
    }
  }
  scrollIndicators() {
    const tabListWidth = this.hostElement.querySelector('.tablist').scrollWidth;
    const containerWidth = this.hostElement.clientWidth + 15;
    const scrollOffset = this.hostElement.querySelector('.tablist').scrollLeft;
    this.showScrollArrows = tabListWidth > containerWidth;
    this.scrollArrowClasses = 'scroll-arrows ';
    if (this.showScrollArrows) {
      if (scrollOffset > 0)
        this.scrollArrowClasses += 'left ';
      if (containerWidth + scrollOffset < tabListWidth)
        this.scrollArrowClasses += 'right ';
    }
  }
  scroll(val) {
    const tabList = this.hostElement.querySelector('.tablist');
    let amount = tabList.scrollLeft + val;
    // Options aren't supported in Safari, I think this might needed as a fallback but might be wrong.
    // tabList.scroll(amount, 0);
    tabList.scroll({
      left: amount,
      behavior: 'smooth',
    });
  }
  /*-------------------------------------- /SCROLL RELATED ---------------------------------------------**/
  getClassNames() {
    let classNames = 'pn-tablist';
    if (this.stackedicons)
      classNames += ' stacked';
    return classNames;
  }
  render() {
    return (h(Host, { role: "tablist", "aria-label": "tablist", class: this.getClassNames() },
      h("div", { class: "tablist" },
        h("slot", null),
        h("div", { class: "line" },
          h("div", { class: "active-line" }),
          h("div", { class: "hovered-line" }))),
      this.showScrollArrows && (h("div", { class: this.scrollArrowClasses },
        h("button", { class: "arrow-left", onClick: () => this.scroll(-120), tabindex: "-1" },
          h("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            h("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M9.414 12l7.293-7.293-1.414-1.414L6.586 12l8.707 8.707 1.414-1.414L9.414 12z" }))),
        h("button", { class: "arrow-right", onClick: () => this.scroll(120), tabindex: "-1" },
          h("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            h("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M8.707 3.293L17.414 12l-8.707 8.707-1.414-1.414L14.586 12 7.293 4.707l1.414-1.414z" })))))));
  }
  static get is() { return "pn-tablist"; }
  static get originalStyleUrls() { return {
    "$": ["pn-tablist.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["pn-tablist.css"]
  }; }
  static get properties() { return {
    "value": {
      "type": "string",
      "mutable": true,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "The value of the tab that is currently active"
      },
      "attribute": "value",
      "reflect": false,
      "defaultValue": "null"
    },
    "stackedicons": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Icons are stacked vertically instead of the default rows"
      },
      "attribute": "stackedicons",
      "reflect": false,
      "defaultValue": "false"
    }
  }; }
  static get states() { return {
    "tabElement": {},
    "showScrollArrows": {},
    "scrollArrowClasses": {}
  }; }
  static get events() { return [{
      "method": "tabchange",
      "name": "tabchange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "This will emit when a tab is changed and is the value you want to bind to your VM state"
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }]; }
  static get elementRef() { return "hostElement"; }
  static get watchers() { return [{
      "propName": "value",
      "methodName": "valueWatcher"
    }, {
      "propName": "showScrollArrows",
      "methodName": "scrollHandler"
    }]; }
  static get listeners() { return [{
      "name": "setactivetab",
      "method": "setActiveTabHandler",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "resize",
      "method": "handleResize",
      "target": "window",
      "capture": false,
      "passive": true
    }]; }
}
