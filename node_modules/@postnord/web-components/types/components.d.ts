/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { PnUploadFileItem } from "./globals/types";
export namespace Components {
    interface PnAccordion {
    }
    interface PnAccordionRow {
        /**
          * The label/title of the accordion row, you can also pass a slot with the name "label" if you want to put custom content in there
         */
        "label": string;
    }
    interface PnButton {
        /**
          * Button type, dark(blue background), light(white background), warning(destructive actions)
         */
        "appearance"?: string;
        "ariaControls"?: string;
        "ariaLabel": string;
        "ariaLabelledby"?: string;
        "ariaPressed": string;
        "download"?: boolean;
        "form"?: string;
        /**
          * Pass an href to make the button into link (a-tag)
         */
        "href"?: string;
        "icon"?: string;
        /**
          * If you're using a button with only an icon, button text is still REQUIRED for the tooltip
         */
        "iconOnly": boolean;
        /**
          * Icon on the left side instead of on the right
         */
        "leftIcon"?: boolean;
        /**
          * Loading indicator
         */
        "loading"?: boolean;
        "rel"?: string;
        /**
          * small, bool
         */
        "small"?: boolean;
        "target"?: string;
        "type"?: string;
        /**
          * Altering the button style, options are: 'outlined' (bordered button with no background) or 'borderless' (borderless button with no background, mostly used for links)
         */
        "variant"?: string;
    }
    interface PnCalendar {
        /**
          * Default date to draw on load.
         */
        "defaultDate": string;
        /**
          * Set specific days to be disabled 'yyyy-mm-dd' format separated by comma
         */
        "disableDays": string;
        /**
          * Disable months view.
         */
        "disableMonthsView": boolean;
        /**
          * Set this to true to disable weekends
         */
        "disableWeekends": boolean;
        /**
          * Supported languages: "en", "sv", "da", "fi", "no"
         */
        "language": string;
        /**
          * Maximum date in 'yyyy-mm-dd' format
         */
        "max": string;
        /**
          * Set the maximum active date. Note: Requires minActiveDate to be set.
         */
        "maxActiveDate": string;
        /**
          * Minimum date in 'yyyy-mm-dd' format
         */
        "min": string;
        /**
          * Set the minimum active date. Note: Requires maxActiveDate to be set.
         */
        "minActiveDate": string;
        /**
          * Force display the months view.
         */
        "monthView": boolean;
        /**
          * Value could be 0-6 where 0 is sunday
         */
        "startOfWeek": number;
        /**
          * Default date value in 'yyyy-mm-dd' format
         */
        "value": string;
    }
    interface PnCheckTile {
        /**
          * REQUIRED!
         */
        "checkboxid": string;
        "checked"?: boolean;
        /**
          * You can pass an illustration name, but if you want to pass your own image you can add an image as a slot with the name of "illustration", check the "tile with slot" story.
         */
        "illustration"?: string;
        /**
          * This will be emitted on change and input
         */
        "value": any;
    }
    interface PnCheckbox {
        "ariaDescribedby": string;
        "ariaLabel": string;
        /**
          * The string you put here will be what you'd make the ID of a native radio button, you can't name props "id" because it's reserved so we went with the more descriptive name "checkboxid", if you want to create labels for your checkbox, you will bind it to this ID
         */
        "checkboxid": string;
        "checked"?: boolean;
        "disabled"?: boolean;
        "indeterminate"?: boolean;
        /**
          * The name of the checkbox group
         */
        "name": string;
        /**
          * This will be emitted on change and input, like a native checkbox
         */
        "value": any;
    }
    interface PnChoiceChip {
        "checked"?: boolean;
        /**
          * The string you put here will be what you'd make the ID of a native checkbox, you can't name props "id" because it's reserved so we went with the more descriptive name "choice", if you want to create labels for your checkbox, you will bind it to this ID
         */
        "choiceid": string;
        "disabled"?: boolean;
        "indeterminate"?: boolean;
        /**
          * The name of the checkbox group
         */
        "name"?: string;
        /**
          * This will be emitted on change and input
         */
        "value": any;
    }
    interface PnColor {
        "defaultColor": string;
        "name": string;
        "palette": Array<object>;
    }
    interface PnColors {
    }
    interface PnDatePicker {
        "disableWeekends": boolean;
        /**
          * Individual dates you want to disable, separated by comma, for example: "YYYY-MM-DD, YYYY-MM-DD..."
         */
        "disabledDates": string;
        /**
          * Initialize with a pre-selected end date, optional
         */
        "end": string;
        /**
          * Placeholder for end date
         */
        "endPlaceholder": string;
        /**
          * Manually set language; this will be inherited from the top-bar
         */
        "language": string;
        /**
          * latest date possible, this will determine how many years forward the date picker will show
         */
        "maxDate": string;
        /**
          * earliest date possible, this will determine how many years back the date picker will show
         */
        "minDate": string;
        /**
          * Placeholder for the input field (this will be start date if you have a ranged date picker)
         */
        "placeholder": string;
        /**
          * Ranged date picker, two dates
         */
        "range": boolean;
        /**
          * Initialize with a pre-selected start date, optional
         */
        "start": string;
    }
    interface PnDatePickerOld {
        /**
          * Set specific days to be disabled 'yyyy-mm-dd' format separated by comma
         */
        "disableDays": string;
        /**
          * Set this to true to disable direct input in the field
         */
        "disableInput": boolean;
        /**
          * Set this to true to disable weekends
         */
        "disableWeekends": boolean;
        /**
          * Disable the date picker if set to true
         */
        "disabled": boolean;
        /**
          * Will fire datechange event on blur if set to true
         */
        "dispatchChangeOnBlur": boolean;
        /**
          * Will fire error event if set to true
         */
        "emitErrors": boolean;
        /**
          * Display red border if set to true
         */
        "invalid": boolean;
        /**
          * Label of the date picker
         */
        "label": string;
        /**
          * Supported languages: "en", "sv", "da", "fi", "no"
         */
        "language": string;
        /**
          * Maximum date in 'yyyy-mm-dd' format
         */
        "max": string;
        /**
          * Minimum date in 'yyyy-mm-dd' format
         */
        "min": string;
        /**
          * Set date picker position Ex. "top left", "bottom right"
         */
        "position": string;
        /**
          * Value could be 0-6 where 0 is sunday
         */
        "startOfWeek": number;
        /**
          * Default date value in 'yyyy-mm-dd' format
         */
        "value": string;
    }
    interface PnFileUpload {
        "accept": string;
        "clearUpload": () => Promise<void>;
        "disabled": boolean;
        "limit": number;
        "maxSize": string;
        "multiple": boolean;
        "removeFile": (targetFile: PnUploadFileItem) => Promise<void>;
        "showSpinner": boolean;
        "startUpload": () => Promise<void>;
        "updateFile": (file: PnUploadFileItem, index?: any) => Promise<void>;
    }
    interface PnFooter {
    }
    interface PnHeader {
        /**
          * By default, the illustration is vertically aligned to the bottom, setting this to true centers it
         */
        "centerIllustration": boolean;
        /**
          * Available colors: blue, coral, orange, gray and green
         */
        "color": string;
        /**
          * heading text
         */
        "heading": string;
        "maxWidth": string;
    }
    interface PnIcon {
        /**
          * Check for the available colors in the knobs panel in the story
         */
        "color": string;
        /**
          * Medium is default but you can pass "small" for a 16x16 icon
         */
        "small": boolean;
        /**
          * The name of the icon you want to use
         */
        "symbol": string;
    }
    interface PnIconGrid {
        "color": string;
        "small": boolean;
    }
    interface PnIllustration {
        "illustration": string;
    }
    interface PnIllustrationGrid {
        "color": string;
        "size": string;
    }
    interface PnInput {
        "ariaLabel": string;
        "autocomplete": string;
        "disabled": boolean;
        /**
          * Error message; will take precedence over helpertext if both are provided (applies invalid styles automatically)
         */
        "error": string;
        /**
          * Text message placed underneath the input field
         */
        "helpertext": string;
        "inputid": string;
        /**
          * Error state without message (If you want to control the error messaging on your own)
         */
        "invalid": boolean;
        /**
          * Text label placed above the input field
         */
        "label": string;
        "max": number;
        /**
          * The maximum number of characters the user should be able to add, also adds a visible counter
         */
        "maxlength": string;
        "min": number;
        "name": string;
        "placeholder": string;
        "required": boolean;
        "type": string;
        "valid": boolean;
        "value": string;
    }
    interface PnMenu {
        "disabled": boolean;
        /**
          * What you write in the comment block above each prop is what ends up in the description fields in the prop table in the documentation
         */
        "testprop": string;
    }
    interface PnModal {
        /**
          * Bind to this property if you want to control the visibility of the modal from your own data.
         */
        "open": boolean;
    }
    interface PnNavDropdown {
        /**
          * Optional icon in the button
         */
        "icon": string;
        /**
          * The label on the button
         */
        "label": string;
    }
    interface PnOcrSearch {
        "language": string;
    }
    interface PnOption {
        "checkbox": boolean;
        "checked": boolean;
        "index": string;
        "parentValue": any;
        "selectHasLoaded": boolean;
        "selected": boolean;
        "value": string;
    }
    interface PnPageNav {
        /**
          * Pass a string which will be the text on the dropdown button. Keep in mind that the dropdown items are passed as slots (<pn-page-nav-dropdown-item />).
         */
        "dropdown": string | boolean;
        /**
          * Currently active menu item value
         */
        "value": string;
    }
    interface PnPageNavDropdownItem {
        /**
          * Ignore this, it's internal communication with parent
         */
        "active": boolean;
        /**
          * Pass an href to the items if you want to have links that lead outside of your app
         */
        "href": string;
        /**
          * The value that will be emitted upon selection, only pass this if the item is a link, if you want a button (for quick actions), omit this prop.
         */
        "value": string;
    }
    interface PnPageNavItem {
        /**
          * Pass an href to the items if you want to have links that lead outside of your app
         */
        "href": string;
        /**
          * Name of the icon
         */
        "icon": string;
        /**
          * Value emitted on navchange
         */
        "value": string;
    }
    interface PnProgressBar {
        "color": string;
        "label": string;
        "progress": number;
        "showPercentage": boolean;
        "showSpinner": boolean;
        "size": string;
        "width": string;
    }
    interface PnProgressIndicator {
        /**
          * Takes the index of the active step
         */
        "activeStep": number;
    }
    interface PnProgressIndicatorStep {
        "active": 'yes' | 'no';
        "activeStep": number;
        "checked": boolean;
        "index": number;
        "name": string;
    }
    interface PnRadioButton {
        "checked"?: boolean;
        "disabled"?: boolean;
        /**
          * The name of the radio button group that will hold this button, like a native radio button
         */
        "name": string;
        /**
          * The string you put here will be what you'd make the ID of a native radio button, you can't name props "id" because it's reserved so we went with the more descriptive name "radioid", if you want to create labels for your button, you will bind it to this ID
         */
        "radioid": string;
        /**
          * This will be emitted on change and input, like a native radio button
         */
        "value": any;
    }
    interface PnRadioTile {
        "checked"?: boolean;
        "illustration"?: string;
        /**
          * REQUIRED! Name of your radio button control group
         */
        "name": string;
        /**
          * REQUIRED! Id, self explanatory
         */
        "radioid": string;
        "value": any;
    }
    interface PnSearchField {
        "ariaLabel": string;
        "autocomplete": string;
        /**
          * Button type, options are 'none' for no button, 'icon' for a labelless button with just a search icon and 'icon-inline' for a search button inside of the search field (this last option disables the clear field button)
         */
        "button": string;
        "disabled": boolean;
        "inputid": string;
        /**
          * Label for the button
         */
        "label": string;
        /**
          * Light instead of dark search button
         */
        "light": boolean;
        "list": string;
        /**
          * Loading animation
         */
        "loading": boolean;
        "name": string;
        "placeholder": string;
        "value": string;
    }
    interface PnSegment {
        "icon": string;
        "name": string;
        "segmentid": string;
        "selected": boolean;
        "value": string;
    }
    interface PnSegmentedControl {
        /**
          * This is the name of the radio buttons inside the controller
         */
        "name": string;
        /**
          * Currently active segment value
         */
        "value": string;
    }
    interface PnSelect {
        /**
          * pass this if you want a checkbox on the parent, you'll have to pass the same prop to all of your children
         */
        "checkbox": boolean;
        /**
          * REQUIRED if you have a checkbox on your select
         */
        "checkboxid": string;
        /**
          * determines the status of the checkbox on the parent
         */
        "checked": boolean;
        /**
          * error message (this will apply the invalid styles automatically)
         */
        "error": string;
        /**
          * determines the status of the checkbox on the parent
         */
        "indeterminate": boolean;
        /**
          * Error state without error message (If you want to control the error messaging on your own)
         */
        "invalid": boolean;
        /**
          * label placed above the select
         */
        "label": string;
        /**
          * this is what will be shown on load if no child is preselected
         */
        "placeholder": string;
        /**
          * this is the placeholder for the search field in the searchable select
         */
        "searchPlaceholder": string;
        /**
          * should this select contain a search field?
         */
        "searchable": boolean;
        "value": string;
    }
    interface PnSpinner {
        /**
          * Light version of the spinner
         */
        "light": boolean;
        /**
          * Size in em
         */
        "size": string;
    }
    interface PnTab {
        "activeTab": string;
        "label": string;
        "value": string;
    }
    interface PnTable {
        /**
          * Add border to table if set to true
         */
        "bordered": boolean;
        /**
          * Make table striped if set to true
         */
        "striped": boolean;
    }
    interface PnTablist {
        /**
          * Icons are stacked vertically instead of the default rows
         */
        "stackedicons": boolean;
        /**
          * The value of the tab that is currently active
         */
        "value": string;
    }
    interface PnTile {
        /**
          * You can pass an illustration name, but if you want to pass your own image you can add an image as a slot with the name of "illustration", check the "tile with slot" story.
         */
        "illustration": string;
        /**
          * Headline of the card and label of the link
         */
        "label": string;
        /**
          * The rel attribute of the link
         */
        "rel"?: string;
        /**
          * The target attribute of the link
         */
        "target": string;
        /**
          * The link of the tile
         */
        "url": string;
    }
    interface PnToast {
        /**
          * success or warning, defaults to blue
         */
        "appearance"?: string;
        /**
          * Show close button?
         */
        "closable"?: boolean;
        /**
          * If you want to control visibility with your own data you can bind to this attribute
         */
        "hidden": boolean;
        /**
          * set left icon
         */
        "icon"?: string;
        /**
          * If you want to set the duration of the visibility manually, time in milliseconds
         */
        "manualDuration"?: number;
        /**
          * Temporarily visible toast, the time of which is determined by the length of your message. Close button will be shown automatically if the time shown exceeds 6s.
         */
        "temporary"?: boolean;
    }
    interface PnToggleSwitch {
        "checked"?: boolean;
        "disabled"?: boolean;
        /**
          * Loading state
         */
        "indeterminate"?: boolean;
        "name"?: string;
        /**
          * Required!
         */
        "toggleid": string;
    }
    interface PnTooltip {
        "color": string;
        "warning": boolean;
    }
    interface PnVirtualAgent {
        "areaid": number;
        /**
          * The ID of the pracel you want to pass to the agent
         */
        "parcelid": string;
        "show": boolean;
    }
    interface PnZipcodeSearch {
        /**
          * marketwebLanguage property will be prioritized before the state language
         */
        "marketwebLanguage": string;
    }
}
export interface PnAccordionRowCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnAccordionRowElement;
}
export interface PnCalendarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnCalendarElement;
}
export interface PnDatePickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnDatePickerElement;
}
export interface PnDatePickerOldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnDatePickerOldElement;
}
export interface PnFileUploadCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnFileUploadElement;
}
export interface PnModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnModalElement;
}
export interface PnOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnOptionElement;
}
export interface PnPageNavCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnPageNavElement;
}
export interface PnPageNavDropdownItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnPageNavDropdownItemElement;
}
export interface PnPageNavItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnPageNavItemElement;
}
export interface PnProgressIndicatorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnProgressIndicatorElement;
}
export interface PnProgressIndicatorStepCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnProgressIndicatorStepElement;
}
export interface PnSearchFieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnSearchFieldElement;
}
export interface PnSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnSelectElement;
}
export interface PnTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnTabElement;
}
export interface PnTablistCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnTablistElement;
}
export interface PnToastCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnToastElement;
}
export interface PnZipcodeSearchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPnZipcodeSearchElement;
}
declare global {
    interface HTMLPnAccordionElement extends Components.PnAccordion, HTMLStencilElement {
    }
    var HTMLPnAccordionElement: {
        prototype: HTMLPnAccordionElement;
        new (): HTMLPnAccordionElement;
    };
    interface HTMLPnAccordionRowElement extends Components.PnAccordionRow, HTMLStencilElement {
    }
    var HTMLPnAccordionRowElement: {
        prototype: HTMLPnAccordionRowElement;
        new (): HTMLPnAccordionRowElement;
    };
    interface HTMLPnButtonElement extends Components.PnButton, HTMLStencilElement {
    }
    var HTMLPnButtonElement: {
        prototype: HTMLPnButtonElement;
        new (): HTMLPnButtonElement;
    };
    interface HTMLPnCalendarElement extends Components.PnCalendar, HTMLStencilElement {
    }
    var HTMLPnCalendarElement: {
        prototype: HTMLPnCalendarElement;
        new (): HTMLPnCalendarElement;
    };
    interface HTMLPnCheckTileElement extends Components.PnCheckTile, HTMLStencilElement {
    }
    var HTMLPnCheckTileElement: {
        prototype: HTMLPnCheckTileElement;
        new (): HTMLPnCheckTileElement;
    };
    interface HTMLPnCheckboxElement extends Components.PnCheckbox, HTMLStencilElement {
    }
    var HTMLPnCheckboxElement: {
        prototype: HTMLPnCheckboxElement;
        new (): HTMLPnCheckboxElement;
    };
    interface HTMLPnChoiceChipElement extends Components.PnChoiceChip, HTMLStencilElement {
    }
    var HTMLPnChoiceChipElement: {
        prototype: HTMLPnChoiceChipElement;
        new (): HTMLPnChoiceChipElement;
    };
    interface HTMLPnColorElement extends Components.PnColor, HTMLStencilElement {
    }
    var HTMLPnColorElement: {
        prototype: HTMLPnColorElement;
        new (): HTMLPnColorElement;
    };
    interface HTMLPnColorsElement extends Components.PnColors, HTMLStencilElement {
    }
    var HTMLPnColorsElement: {
        prototype: HTMLPnColorsElement;
        new (): HTMLPnColorsElement;
    };
    interface HTMLPnDatePickerElement extends Components.PnDatePicker, HTMLStencilElement {
    }
    var HTMLPnDatePickerElement: {
        prototype: HTMLPnDatePickerElement;
        new (): HTMLPnDatePickerElement;
    };
    interface HTMLPnDatePickerOldElement extends Components.PnDatePickerOld, HTMLStencilElement {
    }
    var HTMLPnDatePickerOldElement: {
        prototype: HTMLPnDatePickerOldElement;
        new (): HTMLPnDatePickerOldElement;
    };
    interface HTMLPnFileUploadElement extends Components.PnFileUpload, HTMLStencilElement {
    }
    var HTMLPnFileUploadElement: {
        prototype: HTMLPnFileUploadElement;
        new (): HTMLPnFileUploadElement;
    };
    interface HTMLPnFooterElement extends Components.PnFooter, HTMLStencilElement {
    }
    var HTMLPnFooterElement: {
        prototype: HTMLPnFooterElement;
        new (): HTMLPnFooterElement;
    };
    interface HTMLPnHeaderElement extends Components.PnHeader, HTMLStencilElement {
    }
    var HTMLPnHeaderElement: {
        prototype: HTMLPnHeaderElement;
        new (): HTMLPnHeaderElement;
    };
    interface HTMLPnIconElement extends Components.PnIcon, HTMLStencilElement {
    }
    var HTMLPnIconElement: {
        prototype: HTMLPnIconElement;
        new (): HTMLPnIconElement;
    };
    interface HTMLPnIconGridElement extends Components.PnIconGrid, HTMLStencilElement {
    }
    var HTMLPnIconGridElement: {
        prototype: HTMLPnIconGridElement;
        new (): HTMLPnIconGridElement;
    };
    interface HTMLPnIllustrationElement extends Components.PnIllustration, HTMLStencilElement {
    }
    var HTMLPnIllustrationElement: {
        prototype: HTMLPnIllustrationElement;
        new (): HTMLPnIllustrationElement;
    };
    interface HTMLPnIllustrationGridElement extends Components.PnIllustrationGrid, HTMLStencilElement {
    }
    var HTMLPnIllustrationGridElement: {
        prototype: HTMLPnIllustrationGridElement;
        new (): HTMLPnIllustrationGridElement;
    };
    interface HTMLPnInputElement extends Components.PnInput, HTMLStencilElement {
    }
    var HTMLPnInputElement: {
        prototype: HTMLPnInputElement;
        new (): HTMLPnInputElement;
    };
    interface HTMLPnMenuElement extends Components.PnMenu, HTMLStencilElement {
    }
    var HTMLPnMenuElement: {
        prototype: HTMLPnMenuElement;
        new (): HTMLPnMenuElement;
    };
    interface HTMLPnModalElement extends Components.PnModal, HTMLStencilElement {
    }
    var HTMLPnModalElement: {
        prototype: HTMLPnModalElement;
        new (): HTMLPnModalElement;
    };
    interface HTMLPnNavDropdownElement extends Components.PnNavDropdown, HTMLStencilElement {
    }
    var HTMLPnNavDropdownElement: {
        prototype: HTMLPnNavDropdownElement;
        new (): HTMLPnNavDropdownElement;
    };
    interface HTMLPnOcrSearchElement extends Components.PnOcrSearch, HTMLStencilElement {
    }
    var HTMLPnOcrSearchElement: {
        prototype: HTMLPnOcrSearchElement;
        new (): HTMLPnOcrSearchElement;
    };
    interface HTMLPnOptionElement extends Components.PnOption, HTMLStencilElement {
    }
    var HTMLPnOptionElement: {
        prototype: HTMLPnOptionElement;
        new (): HTMLPnOptionElement;
    };
    interface HTMLPnPageNavElement extends Components.PnPageNav, HTMLStencilElement {
    }
    var HTMLPnPageNavElement: {
        prototype: HTMLPnPageNavElement;
        new (): HTMLPnPageNavElement;
    };
    interface HTMLPnPageNavDropdownItemElement extends Components.PnPageNavDropdownItem, HTMLStencilElement {
    }
    var HTMLPnPageNavDropdownItemElement: {
        prototype: HTMLPnPageNavDropdownItemElement;
        new (): HTMLPnPageNavDropdownItemElement;
    };
    interface HTMLPnPageNavItemElement extends Components.PnPageNavItem, HTMLStencilElement {
    }
    var HTMLPnPageNavItemElement: {
        prototype: HTMLPnPageNavItemElement;
        new (): HTMLPnPageNavItemElement;
    };
    interface HTMLPnProgressBarElement extends Components.PnProgressBar, HTMLStencilElement {
    }
    var HTMLPnProgressBarElement: {
        prototype: HTMLPnProgressBarElement;
        new (): HTMLPnProgressBarElement;
    };
    interface HTMLPnProgressIndicatorElement extends Components.PnProgressIndicator, HTMLStencilElement {
    }
    var HTMLPnProgressIndicatorElement: {
        prototype: HTMLPnProgressIndicatorElement;
        new (): HTMLPnProgressIndicatorElement;
    };
    interface HTMLPnProgressIndicatorStepElement extends Components.PnProgressIndicatorStep, HTMLStencilElement {
    }
    var HTMLPnProgressIndicatorStepElement: {
        prototype: HTMLPnProgressIndicatorStepElement;
        new (): HTMLPnProgressIndicatorStepElement;
    };
    interface HTMLPnRadioButtonElement extends Components.PnRadioButton, HTMLStencilElement {
    }
    var HTMLPnRadioButtonElement: {
        prototype: HTMLPnRadioButtonElement;
        new (): HTMLPnRadioButtonElement;
    };
    interface HTMLPnRadioTileElement extends Components.PnRadioTile, HTMLStencilElement {
    }
    var HTMLPnRadioTileElement: {
        prototype: HTMLPnRadioTileElement;
        new (): HTMLPnRadioTileElement;
    };
    interface HTMLPnSearchFieldElement extends Components.PnSearchField, HTMLStencilElement {
    }
    var HTMLPnSearchFieldElement: {
        prototype: HTMLPnSearchFieldElement;
        new (): HTMLPnSearchFieldElement;
    };
    interface HTMLPnSegmentElement extends Components.PnSegment, HTMLStencilElement {
    }
    var HTMLPnSegmentElement: {
        prototype: HTMLPnSegmentElement;
        new (): HTMLPnSegmentElement;
    };
    interface HTMLPnSegmentedControlElement extends Components.PnSegmentedControl, HTMLStencilElement {
    }
    var HTMLPnSegmentedControlElement: {
        prototype: HTMLPnSegmentedControlElement;
        new (): HTMLPnSegmentedControlElement;
    };
    interface HTMLPnSelectElement extends Components.PnSelect, HTMLStencilElement {
    }
    var HTMLPnSelectElement: {
        prototype: HTMLPnSelectElement;
        new (): HTMLPnSelectElement;
    };
    interface HTMLPnSpinnerElement extends Components.PnSpinner, HTMLStencilElement {
    }
    var HTMLPnSpinnerElement: {
        prototype: HTMLPnSpinnerElement;
        new (): HTMLPnSpinnerElement;
    };
    interface HTMLPnTabElement extends Components.PnTab, HTMLStencilElement {
    }
    var HTMLPnTabElement: {
        prototype: HTMLPnTabElement;
        new (): HTMLPnTabElement;
    };
    interface HTMLPnTableElement extends Components.PnTable, HTMLStencilElement {
    }
    var HTMLPnTableElement: {
        prototype: HTMLPnTableElement;
        new (): HTMLPnTableElement;
    };
    interface HTMLPnTablistElement extends Components.PnTablist, HTMLStencilElement {
    }
    var HTMLPnTablistElement: {
        prototype: HTMLPnTablistElement;
        new (): HTMLPnTablistElement;
    };
    interface HTMLPnTileElement extends Components.PnTile, HTMLStencilElement {
    }
    var HTMLPnTileElement: {
        prototype: HTMLPnTileElement;
        new (): HTMLPnTileElement;
    };
    interface HTMLPnToastElement extends Components.PnToast, HTMLStencilElement {
    }
    var HTMLPnToastElement: {
        prototype: HTMLPnToastElement;
        new (): HTMLPnToastElement;
    };
    interface HTMLPnToggleSwitchElement extends Components.PnToggleSwitch, HTMLStencilElement {
    }
    var HTMLPnToggleSwitchElement: {
        prototype: HTMLPnToggleSwitchElement;
        new (): HTMLPnToggleSwitchElement;
    };
    interface HTMLPnTooltipElement extends Components.PnTooltip, HTMLStencilElement {
    }
    var HTMLPnTooltipElement: {
        prototype: HTMLPnTooltipElement;
        new (): HTMLPnTooltipElement;
    };
    interface HTMLPnVirtualAgentElement extends Components.PnVirtualAgent, HTMLStencilElement {
    }
    var HTMLPnVirtualAgentElement: {
        prototype: HTMLPnVirtualAgentElement;
        new (): HTMLPnVirtualAgentElement;
    };
    interface HTMLPnZipcodeSearchElement extends Components.PnZipcodeSearch, HTMLStencilElement {
    }
    var HTMLPnZipcodeSearchElement: {
        prototype: HTMLPnZipcodeSearchElement;
        new (): HTMLPnZipcodeSearchElement;
    };
    interface HTMLElementTagNameMap {
        "pn-accordion": HTMLPnAccordionElement;
        "pn-accordion-row": HTMLPnAccordionRowElement;
        "pn-button": HTMLPnButtonElement;
        "pn-calendar": HTMLPnCalendarElement;
        "pn-check-tile": HTMLPnCheckTileElement;
        "pn-checkbox": HTMLPnCheckboxElement;
        "pn-choice-chip": HTMLPnChoiceChipElement;
        "pn-color": HTMLPnColorElement;
        "pn-colors": HTMLPnColorsElement;
        "pn-date-picker": HTMLPnDatePickerElement;
        "pn-date-picker-old": HTMLPnDatePickerOldElement;
        "pn-file-upload": HTMLPnFileUploadElement;
        "pn-footer": HTMLPnFooterElement;
        "pn-header": HTMLPnHeaderElement;
        "pn-icon": HTMLPnIconElement;
        "pn-icon-grid": HTMLPnIconGridElement;
        "pn-illustration": HTMLPnIllustrationElement;
        "pn-illustration-grid": HTMLPnIllustrationGridElement;
        "pn-input": HTMLPnInputElement;
        "pn-menu": HTMLPnMenuElement;
        "pn-modal": HTMLPnModalElement;
        "pn-nav-dropdown": HTMLPnNavDropdownElement;
        "pn-ocr-search": HTMLPnOcrSearchElement;
        "pn-option": HTMLPnOptionElement;
        "pn-page-nav": HTMLPnPageNavElement;
        "pn-page-nav-dropdown-item": HTMLPnPageNavDropdownItemElement;
        "pn-page-nav-item": HTMLPnPageNavItemElement;
        "pn-progress-bar": HTMLPnProgressBarElement;
        "pn-progress-indicator": HTMLPnProgressIndicatorElement;
        "pn-progress-indicator-step": HTMLPnProgressIndicatorStepElement;
        "pn-radio-button": HTMLPnRadioButtonElement;
        "pn-radio-tile": HTMLPnRadioTileElement;
        "pn-search-field": HTMLPnSearchFieldElement;
        "pn-segment": HTMLPnSegmentElement;
        "pn-segmented-control": HTMLPnSegmentedControlElement;
        "pn-select": HTMLPnSelectElement;
        "pn-spinner": HTMLPnSpinnerElement;
        "pn-tab": HTMLPnTabElement;
        "pn-table": HTMLPnTableElement;
        "pn-tablist": HTMLPnTablistElement;
        "pn-tile": HTMLPnTileElement;
        "pn-toast": HTMLPnToastElement;
        "pn-toggle-switch": HTMLPnToggleSwitchElement;
        "pn-tooltip": HTMLPnTooltipElement;
        "pn-virtual-agent": HTMLPnVirtualAgentElement;
        "pn-zipcode-search": HTMLPnZipcodeSearchElement;
    }
}
declare namespace LocalJSX {
    interface PnAccordion {
    }
    interface PnAccordionRow {
        /**
          * The label/title of the accordion row, you can also pass a slot with the name "label" if you want to put custom content in there
         */
        "label"?: string;
        /**
          * Ignore this event, it is only to be handled by the accordion parent component
         */
        "onTogglerow"?: (event: PnAccordionRowCustomEvent<any>) => void;
    }
    interface PnButton {
        /**
          * Button type, dark(blue background), light(white background), warning(destructive actions)
         */
        "appearance"?: string;
        "ariaControls"?: string;
        "ariaLabel"?: string;
        "ariaLabelledby"?: string;
        "ariaPressed"?: string;
        "download"?: boolean;
        "form"?: string;
        /**
          * Pass an href to make the button into link (a-tag)
         */
        "href"?: string;
        "icon"?: string;
        /**
          * If you're using a button with only an icon, button text is still REQUIRED for the tooltip
         */
        "iconOnly"?: boolean;
        /**
          * Icon on the left side instead of on the right
         */
        "leftIcon"?: boolean;
        /**
          * Loading indicator
         */
        "loading"?: boolean;
        "rel"?: string;
        /**
          * small, bool
         */
        "small"?: boolean;
        "target"?: string;
        "type"?: string;
        /**
          * Altering the button style, options are: 'outlined' (bordered button with no background) or 'borderless' (borderless button with no background, mostly used for links)
         */
        "variant"?: string;
    }
    interface PnCalendar {
        /**
          * Default date to draw on load.
         */
        "defaultDate"?: string;
        /**
          * Set specific days to be disabled 'yyyy-mm-dd' format separated by comma
         */
        "disableDays"?: string;
        /**
          * Disable months view.
         */
        "disableMonthsView"?: boolean;
        /**
          * Set this to true to disable weekends
         */
        "disableWeekends"?: boolean;
        /**
          * Supported languages: "en", "sv", "da", "fi", "no"
         */
        "language"?: string;
        /**
          * Maximum date in 'yyyy-mm-dd' format
         */
        "max"?: string;
        /**
          * Set the maximum active date. Note: Requires minActiveDate to be set.
         */
        "maxActiveDate"?: string;
        /**
          * Minimum date in 'yyyy-mm-dd' format
         */
        "min"?: string;
        /**
          * Set the minimum active date. Note: Requires maxActiveDate to be set.
         */
        "minActiveDate"?: string;
        /**
          * Force display the months view.
         */
        "monthView"?: boolean;
        /**
          * Event fired when date is changed
         */
        "onDaychange"?: (event: PnCalendarCustomEvent<any>) => void;
        /**
          * Event fired when the month/year is changed
         */
        "onMonthchanged"?: (event: PnCalendarCustomEvent<any>) => void;
        /**
          * Event fired when the user selects the same day
         */
        "onSameday"?: (event: PnCalendarCustomEvent<any>) => void;
        /**
          * Event fired when the view is changed.
         */
        "onViewchange"?: (event: PnCalendarCustomEvent<any>) => void;
        /**
          * Value could be 0-6 where 0 is sunday
         */
        "startOfWeek"?: number;
        /**
          * Default date value in 'yyyy-mm-dd' format
         */
        "value"?: string;
    }
    interface PnCheckTile {
        /**
          * REQUIRED!
         */
        "checkboxid"?: string;
        "checked"?: boolean;
        /**
          * You can pass an illustration name, but if you want to pass your own image you can add an image as a slot with the name of "illustration", check the "tile with slot" story.
         */
        "illustration"?: string;
        /**
          * This will be emitted on change and input
         */
        "value"?: any;
    }
    interface PnCheckbox {
        "ariaDescribedby"?: string;
        "ariaLabel"?: string;
        /**
          * The string you put here will be what you'd make the ID of a native radio button, you can't name props "id" because it's reserved so we went with the more descriptive name "checkboxid", if you want to create labels for your checkbox, you will bind it to this ID
         */
        "checkboxid"?: string;
        "checked"?: boolean;
        "disabled"?: boolean;
        "indeterminate"?: boolean;
        /**
          * The name of the checkbox group
         */
        "name"?: string;
        /**
          * This will be emitted on change and input, like a native checkbox
         */
        "value"?: any;
    }
    interface PnChoiceChip {
        "checked"?: boolean;
        /**
          * The string you put here will be what you'd make the ID of a native checkbox, you can't name props "id" because it's reserved so we went with the more descriptive name "choice", if you want to create labels for your checkbox, you will bind it to this ID
         */
        "choiceid"?: string;
        "disabled"?: boolean;
        "indeterminate"?: boolean;
        /**
          * The name of the checkbox group
         */
        "name"?: string;
        /**
          * This will be emitted on change and input
         */
        "value"?: any;
    }
    interface PnColor {
        "defaultColor"?: string;
        "name"?: string;
        "palette"?: Array<object>;
    }
    interface PnColors {
    }
    interface PnDatePicker {
        "disableWeekends"?: boolean;
        /**
          * Individual dates you want to disable, separated by comma, for example: "YYYY-MM-DD, YYYY-MM-DD..."
         */
        "disabledDates"?: string;
        /**
          * Initialize with a pre-selected end date, optional
         */
        "end"?: string;
        /**
          * Placeholder for end date
         */
        "endPlaceholder"?: string;
        /**
          * Manually set language; this will be inherited from the top-bar
         */
        "language"?: string;
        /**
          * latest date possible, this will determine how many years forward the date picker will show
         */
        "maxDate"?: string;
        /**
          * earliest date possible, this will determine how many years back the date picker will show
         */
        "minDate"?: string;
        /**
          * Emits on valid date selection
         */
        "onDateselection"?: (event: PnDatePickerCustomEvent<any>) => void;
        /**
          * Placeholder for the input field (this will be start date if you have a ranged date picker)
         */
        "placeholder"?: string;
        /**
          * Ranged date picker, two dates
         */
        "range"?: boolean;
        /**
          * Initialize with a pre-selected start date, optional
         */
        "start"?: string;
    }
    interface PnDatePickerOld {
        /**
          * Set specific days to be disabled 'yyyy-mm-dd' format separated by comma
         */
        "disableDays"?: string;
        /**
          * Set this to true to disable direct input in the field
         */
        "disableInput"?: boolean;
        /**
          * Set this to true to disable weekends
         */
        "disableWeekends"?: boolean;
        /**
          * Disable the date picker if set to true
         */
        "disabled"?: boolean;
        /**
          * Will fire datechange event on blur if set to true
         */
        "dispatchChangeOnBlur"?: boolean;
        /**
          * Will fire error event if set to true
         */
        "emitErrors"?: boolean;
        /**
          * Display red border if set to true
         */
        "invalid"?: boolean;
        /**
          * Label of the date picker
         */
        "label"?: string;
        /**
          * Supported languages: "en", "sv", "da", "fi", "no"
         */
        "language"?: string;
        /**
          * Maximum date in 'yyyy-mm-dd' format
         */
        "max"?: string;
        /**
          * Minimum date in 'yyyy-mm-dd' format
         */
        "min"?: string;
        /**
          * Event fired when date is changed
         */
        "onDatechange"?: (event: PnDatePickerOldCustomEvent<any>) => void;
        /**
          * Event fired when there is data error
         */
        "onDateerror"?: (event: PnDatePickerOldCustomEvent<any>) => void;
        /**
          * Event fired when the month/year is changed
         */
        "onMonthchanged"?: (event: PnDatePickerOldCustomEvent<any>) => void;
        /**
          * Set date picker position Ex. "top left", "bottom right"
         */
        "position"?: string;
        /**
          * Value could be 0-6 where 0 is sunday
         */
        "startOfWeek"?: number;
        /**
          * Default date value in 'yyyy-mm-dd' format
         */
        "value"?: string;
    }
    interface PnFileUpload {
        "accept"?: string;
        "disabled"?: boolean;
        "limit"?: number;
        "maxSize"?: string;
        "multiple"?: boolean;
        "onFilesAdded"?: (event: PnFileUploadCustomEvent<any>) => void;
        "onFileuploaderror"?: (event: PnFileUploadCustomEvent<any>) => void;
        "onUpdate"?: (event: PnFileUploadCustomEvent<any>) => void;
        "onUploadCancelled"?: (event: PnFileUploadCustomEvent<any>) => void;
        "onUploadCompleted"?: (event: PnFileUploadCustomEvent<any>) => void;
        "onUploadFile"?: (event: PnFileUploadCustomEvent<any>) => void;
        "onValid"?: (event: PnFileUploadCustomEvent<any>) => void;
        "showSpinner"?: boolean;
    }
    interface PnFooter {
    }
    interface PnHeader {
        /**
          * By default, the illustration is vertically aligned to the bottom, setting this to true centers it
         */
        "centerIllustration"?: boolean;
        /**
          * Available colors: blue, coral, orange, gray and green
         */
        "color"?: string;
        /**
          * heading text
         */
        "heading"?: string;
        "maxWidth"?: string;
    }
    interface PnIcon {
        /**
          * Check for the available colors in the knobs panel in the story
         */
        "color"?: string;
        /**
          * Medium is default but you can pass "small" for a 16x16 icon
         */
        "small"?: boolean;
        /**
          * The name of the icon you want to use
         */
        "symbol"?: string;
    }
    interface PnIconGrid {
        "color"?: string;
        "small"?: boolean;
    }
    interface PnIllustration {
        "illustration"?: string;
    }
    interface PnIllustrationGrid {
        "color"?: string;
        "size"?: string;
    }
    interface PnInput {
        "ariaLabel"?: string;
        "autocomplete"?: string;
        "disabled"?: boolean;
        /**
          * Error message; will take precedence over helpertext if both are provided (applies invalid styles automatically)
         */
        "error"?: string;
        /**
          * Text message placed underneath the input field
         */
        "helpertext"?: string;
        "inputid"?: string;
        /**
          * Error state without message (If you want to control the error messaging on your own)
         */
        "invalid"?: boolean;
        /**
          * Text label placed above the input field
         */
        "label"?: string;
        "max"?: number;
        /**
          * The maximum number of characters the user should be able to add, also adds a visible counter
         */
        "maxlength"?: string;
        "min"?: number;
        "name"?: string;
        "placeholder"?: string;
        "required"?: boolean;
        "type"?: string;
        "valid"?: boolean;
        "value"?: string;
    }
    interface PnMenu {
        "disabled"?: boolean;
        /**
          * What you write in the comment block above each prop is what ends up in the description fields in the prop table in the documentation
         */
        "testprop"?: string;
    }
    interface PnModal {
        /**
          * Event fired when the modal is closed, either by clicking outside or by triggering close button.
         */
        "onClose"?: (event: PnModalCustomEvent<any>) => void;
        /**
          * Bind to this property if you want to control the visibility of the modal from your own data.
         */
        "open"?: boolean;
    }
    interface PnNavDropdown {
        /**
          * Optional icon in the button
         */
        "icon"?: string;
        /**
          * The label on the button
         */
        "label"?: string;
    }
    interface PnOcrSearch {
        "language"?: string;
    }
    interface PnOption {
        "checkbox"?: boolean;
        "checked"?: boolean;
        "index"?: string;
        /**
          * If you have checkboxes on your options and want to bind the value on change, listen for this event on the pn-options themselves
         */
        "onCheckchange"?: (event: PnOptionCustomEvent<any>) => void;
        /**
          * This event is solely here to communicate with pn-select, listen for changes on pn-select rather than here
         */
        "onSelectOption"?: (event: PnOptionCustomEvent<any>) => void;
        "parentValue"?: any;
        "selectHasLoaded"?: boolean;
        "selected"?: boolean;
        "value"?: string;
    }
    interface PnPageNav {
        /**
          * Pass a string which will be the text on the dropdown button. Keep in mind that the dropdown items are passed as slots (<pn-page-nav-dropdown-item />).
         */
        "dropdown"?: string | boolean;
        /**
          * Emitted when active value changes
         */
        "onNavchange"?: (event: PnPageNavCustomEvent<any>) => void;
        /**
          * Currently active menu item value
         */
        "value"?: string;
    }
    interface PnPageNavDropdownItem {
        /**
          * Ignore this, it's internal communication with parent
         */
        "active"?: boolean;
        /**
          * Pass an href to the items if you want to have links that lead outside of your app
         */
        "href"?: string;
        /**
          * Ignore this, it's internal communication with parent
         */
        "onItemselection"?: (event: PnPageNavDropdownItemCustomEvent<any>) => void;
        /**
          * The value that will be emitted upon selection, only pass this if the item is a link, if you want a button (for quick actions), omit this prop.
         */
        "value"?: string;
    }
    interface PnPageNavItem {
        /**
          * Pass an href to the items if you want to have links that lead outside of your app
         */
        "href"?: string;
        /**
          * Name of the icon
         */
        "icon"?: string;
        "onItemselection"?: (event: PnPageNavItemCustomEvent<any>) => void;
        /**
          * Value emitted on navchange
         */
        "value"?: string;
    }
    interface PnProgressBar {
        "color"?: string;
        "label"?: string;
        "progress"?: number;
        "showPercentage"?: boolean;
        "showSpinner"?: boolean;
        "size"?: string;
        "width"?: string;
    }
    interface PnProgressIndicator {
        /**
          * Takes the index of the active step
         */
        "activeStep"?: number;
        /**
          * This will emit when progress is changed and is the value you want to bind to your VM state
         */
        "onProgresschange"?: (event: PnProgressIndicatorCustomEvent<any>) => void;
    }
    interface PnProgressIndicatorStep {
        "active"?: 'yes' | 'no';
        "activeStep"?: number;
        "checked"?: boolean;
        "index"?: number;
        "name"?: string;
        "onSetactivestep"?: (event: PnProgressIndicatorStepCustomEvent<any>) => void;
    }
    interface PnRadioButton {
        "checked"?: boolean;
        "disabled"?: boolean;
        /**
          * The name of the radio button group that will hold this button, like a native radio button
         */
        "name"?: string;
        /**
          * The string you put here will be what you'd make the ID of a native radio button, you can't name props "id" because it's reserved so we went with the more descriptive name "radioid", if you want to create labels for your button, you will bind it to this ID
         */
        "radioid"?: string;
        /**
          * This will be emitted on change and input, like a native radio button
         */
        "value"?: any;
    }
    interface PnRadioTile {
        "checked"?: boolean;
        "illustration"?: string;
        /**
          * REQUIRED! Name of your radio button control group
         */
        "name"?: string;
        /**
          * REQUIRED! Id, self explanatory
         */
        "radioid"?: string;
        "value"?: any;
    }
    interface PnSearchField {
        "ariaLabel"?: string;
        "autocomplete"?: string;
        /**
          * Button type, options are 'none' for no button, 'icon' for a labelless button with just a search icon and 'icon-inline' for a search button inside of the search field (this last option disables the clear field button)
         */
        "button"?: string;
        "disabled"?: boolean;
        "inputid"?: string;
        /**
          * Label for the button
         */
        "label"?: string;
        /**
          * Light instead of dark search button
         */
        "light"?: boolean;
        "list"?: string;
        /**
          * Loading animation
         */
        "loading"?: boolean;
        "name"?: string;
        /**
          * This is emitted on search submission both with keyboard and mouse
         */
        "onSearch"?: (event: PnSearchFieldCustomEvent<any>) => void;
        /**
          * custom event that handles both clearing and input to have the option of just binding listeners to one event instead of two.
         */
        "onUpdate"?: (event: PnSearchFieldCustomEvent<any>) => void;
        "placeholder"?: string;
        "value"?: string;
    }
    interface PnSegment {
        "icon"?: string;
        "name"?: string;
        "segmentid"?: string;
        "selected"?: boolean;
        "value"?: string;
    }
    interface PnSegmentedControl {
        /**
          * This is the name of the radio buttons inside the controller
         */
        "name"?: string;
        /**
          * Currently active segment value
         */
        "value"?: string;
    }
    interface PnSelect {
        /**
          * pass this if you want a checkbox on the parent, you'll have to pass the same prop to all of your children
         */
        "checkbox"?: boolean;
        /**
          * REQUIRED if you have a checkbox on your select
         */
        "checkboxid"?: string;
        /**
          * determines the status of the checkbox on the parent
         */
        "checked"?: boolean;
        /**
          * error message (this will apply the invalid styles automatically)
         */
        "error"?: string;
        /**
          * determines the status of the checkbox on the parent
         */
        "indeterminate"?: boolean;
        /**
          * Error state without error message (If you want to control the error messaging on your own)
         */
        "invalid"?: boolean;
        /**
          * label placed above the select
         */
        "label"?: string;
        /**
          * this will be emitted when the value of the parent checkbox changes
         */
        "onCheckchange"?: (event: PnSelectCustomEvent<any>) => void;
        /**
          * this will be emitted when the current selection changes
         */
        "onSelectchange"?: (event: PnSelectCustomEvent<any>) => void;
        /**
          * this is what will be shown on load if no child is preselected
         */
        "placeholder"?: string;
        /**
          * this is the placeholder for the search field in the searchable select
         */
        "searchPlaceholder"?: string;
        /**
          * should this select contain a search field?
         */
        "searchable"?: boolean;
        "value"?: string;
    }
    interface PnSpinner {
        /**
          * Light version of the spinner
         */
        "light"?: boolean;
        /**
          * Size in em
         */
        "size"?: string;
    }
    interface PnTab {
        "activeTab"?: string;
        "label"?: string;
        "onSetactivetab"?: (event: PnTabCustomEvent<any>) => void;
        "value"?: string;
    }
    interface PnTable {
        /**
          * Add border to table if set to true
         */
        "bordered"?: boolean;
        /**
          * Make table striped if set to true
         */
        "striped"?: boolean;
    }
    interface PnTablist {
        /**
          * This will emit when a tab is changed and is the value you want to bind to your VM state
         */
        "onTabchange"?: (event: PnTablistCustomEvent<any>) => void;
        /**
          * Icons are stacked vertically instead of the default rows
         */
        "stackedicons"?: boolean;
        /**
          * The value of the tab that is currently active
         */
        "value"?: string;
    }
    interface PnTile {
        /**
          * You can pass an illustration name, but if you want to pass your own image you can add an image as a slot with the name of "illustration", check the "tile with slot" story.
         */
        "illustration"?: string;
        /**
          * Headline of the card and label of the link
         */
        "label"?: string;
        /**
          * The rel attribute of the link
         */
        "rel"?: string;
        /**
          * The target attribute of the link
         */
        "target"?: string;
        /**
          * The link of the tile
         */
        "url"?: string;
    }
    interface PnToast {
        /**
          * success or warning, defaults to blue
         */
        "appearance"?: string;
        /**
          * Show close button?
         */
        "closable"?: boolean;
        /**
          * If you want to control visibility with your own data you can bind to this attribute
         */
        "hidden"?: boolean;
        /**
          * set left icon
         */
        "icon"?: string;
        /**
          * If you want to set the duration of the visibility manually, time in milliseconds
         */
        "manualDuration"?: number;
        /**
          * Event fired when close button is pressed and when the temporary toast closes itself
         */
        "onClose"?: (event: PnToastCustomEvent<any>) => void;
        /**
          * Temporarily visible toast, the time of which is determined by the length of your message. Close button will be shown automatically if the time shown exceeds 6s.
         */
        "temporary"?: boolean;
    }
    interface PnToggleSwitch {
        "checked"?: boolean;
        "disabled"?: boolean;
        /**
          * Loading state
         */
        "indeterminate"?: boolean;
        "name"?: string;
        /**
          * Required!
         */
        "toggleid"?: string;
    }
    interface PnTooltip {
        "color"?: string;
        "warning"?: boolean;
    }
    interface PnVirtualAgent {
        "areaid"?: number;
        /**
          * The ID of the pracel you want to pass to the agent
         */
        "parcelid"?: string;
        "show"?: boolean;
    }
    interface PnZipcodeSearch {
        /**
          * marketwebLanguage property will be prioritized before the state language
         */
        "marketwebLanguage"?: string;
        /**
          * Event fired when search has result
         */
        "onSearchsuccessful"?: (event: PnZipcodeSearchCustomEvent<any>) => void;
    }
    interface IntrinsicElements {
        "pn-accordion": PnAccordion;
        "pn-accordion-row": PnAccordionRow;
        "pn-button": PnButton;
        "pn-calendar": PnCalendar;
        "pn-check-tile": PnCheckTile;
        "pn-checkbox": PnCheckbox;
        "pn-choice-chip": PnChoiceChip;
        "pn-color": PnColor;
        "pn-colors": PnColors;
        "pn-date-picker": PnDatePicker;
        "pn-date-picker-old": PnDatePickerOld;
        "pn-file-upload": PnFileUpload;
        "pn-footer": PnFooter;
        "pn-header": PnHeader;
        "pn-icon": PnIcon;
        "pn-icon-grid": PnIconGrid;
        "pn-illustration": PnIllustration;
        "pn-illustration-grid": PnIllustrationGrid;
        "pn-input": PnInput;
        "pn-menu": PnMenu;
        "pn-modal": PnModal;
        "pn-nav-dropdown": PnNavDropdown;
        "pn-ocr-search": PnOcrSearch;
        "pn-option": PnOption;
        "pn-page-nav": PnPageNav;
        "pn-page-nav-dropdown-item": PnPageNavDropdownItem;
        "pn-page-nav-item": PnPageNavItem;
        "pn-progress-bar": PnProgressBar;
        "pn-progress-indicator": PnProgressIndicator;
        "pn-progress-indicator-step": PnProgressIndicatorStep;
        "pn-radio-button": PnRadioButton;
        "pn-radio-tile": PnRadioTile;
        "pn-search-field": PnSearchField;
        "pn-segment": PnSegment;
        "pn-segmented-control": PnSegmentedControl;
        "pn-select": PnSelect;
        "pn-spinner": PnSpinner;
        "pn-tab": PnTab;
        "pn-table": PnTable;
        "pn-tablist": PnTablist;
        "pn-tile": PnTile;
        "pn-toast": PnToast;
        "pn-toggle-switch": PnToggleSwitch;
        "pn-tooltip": PnTooltip;
        "pn-virtual-agent": PnVirtualAgent;
        "pn-zipcode-search": PnZipcodeSearch;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "pn-accordion": LocalJSX.PnAccordion & JSXBase.HTMLAttributes<HTMLPnAccordionElement>;
            "pn-accordion-row": LocalJSX.PnAccordionRow & JSXBase.HTMLAttributes<HTMLPnAccordionRowElement>;
            "pn-button": LocalJSX.PnButton & JSXBase.HTMLAttributes<HTMLPnButtonElement>;
            "pn-calendar": LocalJSX.PnCalendar & JSXBase.HTMLAttributes<HTMLPnCalendarElement>;
            "pn-check-tile": LocalJSX.PnCheckTile & JSXBase.HTMLAttributes<HTMLPnCheckTileElement>;
            "pn-checkbox": LocalJSX.PnCheckbox & JSXBase.HTMLAttributes<HTMLPnCheckboxElement>;
            "pn-choice-chip": LocalJSX.PnChoiceChip & JSXBase.HTMLAttributes<HTMLPnChoiceChipElement>;
            "pn-color": LocalJSX.PnColor & JSXBase.HTMLAttributes<HTMLPnColorElement>;
            "pn-colors": LocalJSX.PnColors & JSXBase.HTMLAttributes<HTMLPnColorsElement>;
            "pn-date-picker": LocalJSX.PnDatePicker & JSXBase.HTMLAttributes<HTMLPnDatePickerElement>;
            "pn-date-picker-old": LocalJSX.PnDatePickerOld & JSXBase.HTMLAttributes<HTMLPnDatePickerOldElement>;
            "pn-file-upload": LocalJSX.PnFileUpload & JSXBase.HTMLAttributes<HTMLPnFileUploadElement>;
            "pn-footer": LocalJSX.PnFooter & JSXBase.HTMLAttributes<HTMLPnFooterElement>;
            "pn-header": LocalJSX.PnHeader & JSXBase.HTMLAttributes<HTMLPnHeaderElement>;
            "pn-icon": LocalJSX.PnIcon & JSXBase.HTMLAttributes<HTMLPnIconElement>;
            "pn-icon-grid": LocalJSX.PnIconGrid & JSXBase.HTMLAttributes<HTMLPnIconGridElement>;
            "pn-illustration": LocalJSX.PnIllustration & JSXBase.HTMLAttributes<HTMLPnIllustrationElement>;
            "pn-illustration-grid": LocalJSX.PnIllustrationGrid & JSXBase.HTMLAttributes<HTMLPnIllustrationGridElement>;
            "pn-input": LocalJSX.PnInput & JSXBase.HTMLAttributes<HTMLPnInputElement>;
            "pn-menu": LocalJSX.PnMenu & JSXBase.HTMLAttributes<HTMLPnMenuElement>;
            "pn-modal": LocalJSX.PnModal & JSXBase.HTMLAttributes<HTMLPnModalElement>;
            "pn-nav-dropdown": LocalJSX.PnNavDropdown & JSXBase.HTMLAttributes<HTMLPnNavDropdownElement>;
            "pn-ocr-search": LocalJSX.PnOcrSearch & JSXBase.HTMLAttributes<HTMLPnOcrSearchElement>;
            "pn-option": LocalJSX.PnOption & JSXBase.HTMLAttributes<HTMLPnOptionElement>;
            "pn-page-nav": LocalJSX.PnPageNav & JSXBase.HTMLAttributes<HTMLPnPageNavElement>;
            "pn-page-nav-dropdown-item": LocalJSX.PnPageNavDropdownItem & JSXBase.HTMLAttributes<HTMLPnPageNavDropdownItemElement>;
            "pn-page-nav-item": LocalJSX.PnPageNavItem & JSXBase.HTMLAttributes<HTMLPnPageNavItemElement>;
            "pn-progress-bar": LocalJSX.PnProgressBar & JSXBase.HTMLAttributes<HTMLPnProgressBarElement>;
            "pn-progress-indicator": LocalJSX.PnProgressIndicator & JSXBase.HTMLAttributes<HTMLPnProgressIndicatorElement>;
            "pn-progress-indicator-step": LocalJSX.PnProgressIndicatorStep & JSXBase.HTMLAttributes<HTMLPnProgressIndicatorStepElement>;
            "pn-radio-button": LocalJSX.PnRadioButton & JSXBase.HTMLAttributes<HTMLPnRadioButtonElement>;
            "pn-radio-tile": LocalJSX.PnRadioTile & JSXBase.HTMLAttributes<HTMLPnRadioTileElement>;
            "pn-search-field": LocalJSX.PnSearchField & JSXBase.HTMLAttributes<HTMLPnSearchFieldElement>;
            "pn-segment": LocalJSX.PnSegment & JSXBase.HTMLAttributes<HTMLPnSegmentElement>;
            "pn-segmented-control": LocalJSX.PnSegmentedControl & JSXBase.HTMLAttributes<HTMLPnSegmentedControlElement>;
            "pn-select": LocalJSX.PnSelect & JSXBase.HTMLAttributes<HTMLPnSelectElement>;
            "pn-spinner": LocalJSX.PnSpinner & JSXBase.HTMLAttributes<HTMLPnSpinnerElement>;
            "pn-tab": LocalJSX.PnTab & JSXBase.HTMLAttributes<HTMLPnTabElement>;
            "pn-table": LocalJSX.PnTable & JSXBase.HTMLAttributes<HTMLPnTableElement>;
            "pn-tablist": LocalJSX.PnTablist & JSXBase.HTMLAttributes<HTMLPnTablistElement>;
            "pn-tile": LocalJSX.PnTile & JSXBase.HTMLAttributes<HTMLPnTileElement>;
            "pn-toast": LocalJSX.PnToast & JSXBase.HTMLAttributes<HTMLPnToastElement>;
            "pn-toggle-switch": LocalJSX.PnToggleSwitch & JSXBase.HTMLAttributes<HTMLPnToggleSwitchElement>;
            "pn-tooltip": LocalJSX.PnTooltip & JSXBase.HTMLAttributes<HTMLPnTooltipElement>;
            "pn-virtual-agent": LocalJSX.PnVirtualAgent & JSXBase.HTMLAttributes<HTMLPnVirtualAgentElement>;
            "pn-zipcode-search": LocalJSX.PnZipcodeSearch & JSXBase.HTMLAttributes<HTMLPnZipcodeSearchElement>;
        }
    }
}
